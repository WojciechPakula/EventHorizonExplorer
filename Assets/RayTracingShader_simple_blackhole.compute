#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> Result;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float4 _DirectionalLight;

float2 _PixelOffset;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

//float _floatArr[1000000];
StructuredBuffer<float> _textureGravity;

Texture2D<float> _FloatTexture;
SamplerState sampler_FloatTexture;

static const float PI = 3.14159265f;

int _interpolationMode;
int _axisMode;

int _textureWidth;
int _textureHeight;

//TESTY
struct SubMeshMaterial
{
    int sub;
    int textureId;
    float4 c;
    float2 tiling;
    float2 offset;
};
struct TransformPack
{
    int meshId;
    float3 position;
    float4 rotation;
    float3 scale;
};
StructuredBuffer<float3> _static_V;
StructuredBuffer<float3> _static_N;
StructuredBuffer<float2> _static_UV;
StructuredBuffer<int3> _static_T;
StructuredBuffer<float3> _static_B;
StructuredBuffer<int3> _static_bvh;
StructuredBuffer<SubMeshMaterial> _static_SUB2;
StructuredBuffer<int> _static_IND;

StructuredBuffer<TransformPack> _static_transforms;


//TESTY

//Teksturowanie
StructuredBuffer<float4> _static_Textures;
StructuredBuffer<int3> _static_Textures_IND;//table start index, width, height
float4 getPixel(float2 UV, SubMeshMaterial mat)
{
    int3 dat = _static_Textures_IND[mat.textureId];
    int t_ = dat.x;//index
    int w = dat.y;//width
    int h = dat.z;//height

    float2 UV2 = UV * mat.tiling + mat.offset;

    UV2.x = (UV2.x - (int) UV2.x);
    UV2.y = (UV2.y - (int) UV2.y);

    float2 pos = float2(UV2.x * (float)w, UV2.y * (float)h);

    int2 posInt = int2((int)pos.x, (int)pos.y);

    float4 col = _static_Textures[t_ + (posInt.y * w + posInt.x)];
    //float4 col = float4(UV.x, UV.y, 0, 0);

    //float4 col = _static_Textures[t_ + (250 * w + 135)];
    //float4 col = float4(UV.x, UV.y, 0, 0);
    return col;
}
//

//-------------------------------------
//- PRZECIĘCIE TRÓJKĄTA
bool rayTriangleCheck(float3 rayOrigin,
                           float3 rayVector,
                           float3 vertex0,
                           float3 vertex1,
                           float3 vertex2,
                           out float3 outIntersectionPoint)
{
    outIntersectionPoint = float3(0,0,0);

    float EPSILON = 0.0000001f;
    float3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    if (a > -EPSILON && a < EPSILON)
        return false; // This ray is parallel to this triangle.
    f = 1.0f / a;
    s = rayOrigin - vertex0;
    u = f * (dot(s, h));
    if (u < 0.0 || u > 1.0)
        return false;
    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    if (v < 0.0 || u + v > 1.0)
        return false;
        // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON) // ray intersection
    {
        outIntersectionPoint = rayOrigin + rayVector * t;
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}

//- PRZECIĘCIE BOXA
float max3(float a, float b, float c)
{
    return max(a, max(b, c));
}
float min3(float a, float b, float c)
{
    return min(a, min(b, c));
}

bool rayBoxCheck(float3 p, float3 d, float3 a, float3 A)
{
    float t1 = (a.x - p.x) / d.x;
    float t2 = (A.x - p.x) / d.x;
    float t3 = (a.y - p.y) / d.y;
    float t4 = (A.y - p.y) / d.y;
    float t5 = (a.z - p.z) / d.z;
    float t6 = (A.z - p.z) / d.z;
    float tmin = max3(min(t1, t2), min(t3, t4), min(t5, t6));
    float tmax = min3(max(t1, t2), max(t3, t4), max(t5, t6));
    if (tmax < 0)
        return false;
    else if (tmin > tmax)
        return false;
    return true;
}



//WYKRYWANIE OBIEKTOW
bool BVHsearch(float3 origin_, float3 direction_, float3 scale, int bvh_, int b_, int t_, int v_, int s_, int s_c, out float3 output, out float4 color)
{
    int stos[100];
    int stosIndex = 0;

    int bvhindex = 0;
    int lastindex = 0;

    bool stopCondition = false;

    bool emptyHit = true;
    float3 bestHit = float3(0, 0, 0);
    float bestHitDist = 9999999;
    int bestTriangleId = 0;

    //int loopLimiter = 100000;//duża wartosc
    int loopLimiter = 10000; //duża wartosc

    while (true)
    {
        loopLimiter--;
        if (loopLimiter <= 0)
            break;

        stos[stosIndex] = bvhindex;
        int currentIndex = bvhindex;
        int3 node = _static_bvh[bvhindex + bvh_];

        if (node.y == 0 && node.z == 0)
        {
            //triangle
            float3 trOutput;
            bool res = rayTriangleCheck(origin_, direction_, _static_V[_static_T[node.x + t_].x + v_] * scale, _static_V[_static_T[node.x + t_].y + v_] * scale, _static_V[_static_T[node.x + t_].z + v_] * scale, trOutput);
        
            if (res)
            {
                float f = length(trOutput - origin_);
                if (emptyHit == true || f < bestHitDist)
                {
                    emptyHit = false;
                    bestHitDist = f;
                    bestHit = trOutput;
                    bestTriangleId = node.x;
                }
            }

            //w gore
            stosIndex--;
            if (stosIndex < 0)
                break;
            bvhindex = stos[stosIndex];
        } else
        {
            //check collision
            //box
            if (lastindex != node.y && lastindex != node.z)
            {
                bool res = rayBoxCheck(origin_, direction_, _static_B[node.x + b_] * scale, _static_B[node.x + b_ + 1] * scale);
                if (res)
                {
                    //wejdz w lewy
                    bvhindex = node.y;
                    stosIndex++;
                }
                else
                {
                    stosIndex--;
                    if (stosIndex < 0)
                        break;
                    bvhindex = stos[stosIndex];
                }
            } else if (lastindex == node.y)
            {
                //wejdz w prawy
                bvhindex = node.z;
                stosIndex++;
            }
            else if (lastindex == node.z)
            {
                //wroc w gore
                stosIndex--;
                if (stosIndex < 0)
                    break;
                bvhindex = stos[stosIndex];
            }
        }
        lastindex = currentIndex;
    }
    //koniec petli
    output = bestHit;
    color = float4(1,1,0,0);
    if (!emptyHit && true)
    {
        //trafienie
        //int3 tr = _static_T[ bestTriangleId+t_];
        SubMeshMaterial mat;
        /*if (s_c == 3)
        {
            //color = float4(1, 0, 1, 0);
            mat = _static_SUB2[s_+2];
            color = mat.c;
        }*/
        if(s_c == 1){
            mat = _static_SUB2[s_];
        } 
        else if (s_c > 1)
        {
            for (int i = s_c - 1; i >= 0; --i)
            {
                SubMeshMaterial mat0 = _static_SUB2[s_ + i];
                if (bestTriangleId >= mat0.sub)
                {
                    mat = mat0;
                    break;
                }
            }
        }
        if (mat.textureId == -1)
            color = mat.c;
        else
        {
            color = mat.c;
            int3 tr = _static_T[t_ + bestTriangleId];
            float3 A = _static_V[v_ + tr.x] * scale;
            float3 B = _static_V[v_ + tr.y] * scale;
            float3 C = _static_V[v_ + tr.z] * scale;
            float2 UVA = _static_UV[v_ + tr.x];
            float2 UVB = _static_UV[v_ + tr.y];
            float2 UVC = _static_UV[v_ + tr.z];

            

            float3 Ce = bestHit;

            float3 A_diff = (B - A);
            float3 B_diff = (C - B);
            float3 C_diff = (A - C);
            
            float P0 = length(cross(A_diff, C_diff)) / 2.0f;

            float PC = length(cross(A_diff, (Ce - A)) / 2.0f) / P0;
            float PA = length(cross(B_diff, (Ce - B)) / 2.0f) / P0;
            float PB = length(cross(C_diff, (Ce - C)) / 2.0f) / P0;

            float2 UV = (UVA * PA) + (UVB * PB) + (UVC * PC);

            color = getPixel(UV, mat);
            //color = float4(PA, PB, PC, 0);
        }
    }
    return !emptyHit;
}

float4 quaternionInv(float4 q)
{
    float sum = q.x * q.x +
        q.y * q.y +
        q.z * q.z +
        q.w * q.w;
    return float4(-q.x / sum, -q.y / sum, -q.z / sum, q.w / sum);
}
float4 quaternionCross(float4 q, float4 r)
{
    float t0 = q.x * r.x - q.y * r.y - q.z * r.z - q.w * r.w;
    float t1 = q.y * r.x + q.x * r.y - q.w * r.z + q.z * r.w;
    float t2 = q.z * r.x + q.w * r.y + q.x * r.z - q.y * r.w;
    float t3 = q.w * r.x - q.z * r.y + q.y * r.z + q.x * r.w;
    return float4(t0,t1,t2,t3);
}
float3 vectorQRotation(float3 v, float4 q)
{
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;
    float3 m1 = float3(1 - 2 * y * y - 2 * z * z, 2 * x * y - 2 * z * w, 2 * x * z + 2 * y * w);
    float3 m2 = float3(2 * x * y + 2 * z * w, 1 - 2 * x * x - 2 * z * z, 2 * y * z - 2 * x * w);
    float3 m3 = float3(2 * x * z - 2 * y * w, 2 * y * z + 2 * x * w, 1 - 2 * x * x - 2 * y * y);

    return float3(dot(m1, v), dot(m2, v), dot(m3, v));
}

bool rayMeshCollisionChecker(float3 origin, float3 direction, out float4 color, out float3 outHitPoint)
{
    //color = float4(0, 0, 0, 1);
    color = float4(direction.x * direction.x + origin.x / 100.0f, direction.y * direction.y + origin.y / 100.0f, direction.z * direction.z + origin.z / 100.0f, 1);
    outHitPoint = float3(0, 0, 0);
    uint numObj, stride;
    _static_transforms.GetDimensions(numObj, stride);

    /*if (direction.z < 0)
    {
        return true;
    }*/

    bool emptyHit = true;
    float mind = 0;
    for (int i = 0; i < numObj; ++i)//killer
    {
        TransformPack obj = _static_transforms[i];

        /*if (obj.position.x > 0)
        {
            color.r = 0;
        }
        if (obj.position.x < 0)
        {
            color.g = 0;
        }
        if (obj.rotation.x > 0)
        {
            color.b = 0;
        }*/

        float4 invRotation = quaternionInv(obj.rotation);
        float3 diff = origin - obj.position;
        
        float3 origin_ = vectorQRotation(diff, invRotation);
        float3 direction_ = vectorQRotation(direction, invRotation);

        //color = float4(direction_.x * direction_.x + origin_.x / 100.0f, direction_.y * direction_.y + origin_.y / 100.0f, direction_.z * direction_.z + origin_.z / 100.0f, 1);
    

        int index = obj.meshId * 6;

        int id = _static_IND[index + 0];
        int bvh = _static_IND[index + 1];
        int b = _static_IND[index + 2];
        int t = _static_IND[index + 3];
        int v = _static_IND[index + 4];
        int s = _static_IND[index + 5];
        int id_, bvh_,b_,t_,v_,s_;

        int IND_size;
        _static_IND.GetDimensions((uint) IND_size, stride);
        int Statics_count = IND_size / 6;


        if (index < Statics_count - 1)
        {
            index+=6;
            bvh_ = _static_IND[index + 1];
            b_ = _static_IND[index + 2];
            t_ = _static_IND[index + 3];
            v_ = _static_IND[index + 4];
            s_ = _static_IND[index + 5];
        }
        else
        {
            _static_bvh.GetDimensions((uint) bvh_, stride);
            _static_B.GetDimensions((uint)b_, stride);
            _static_T.GetDimensions((uint)t_, stride);
            _static_V.GetDimensions((uint)v_, stride);
            _static_SUB2.GetDimensions((uint)s_, stride);
        }

        float3 hitpoint;
        float4 c;

        bool hit = BVHsearch(origin_, direction_, obj.scale, bvh, b, t, v, s, (s_ - s), hitpoint, c);

        if (hit)
        {
            //emptyHit = false;
            //color = float4(1, 0.5f, 0.5f, 1);
            float d = distance(origin_, hitpoint);
            if (d < mind || emptyHit)
            {
                mind = d;
                hitpoint = vectorQRotation(hitpoint, obj.rotation);
                hitpoint += obj.position;
                outHitPoint = hitpoint;
                emptyHit = false;
                //color = float4(0.0f, 1.0f, 0.5f, 1);
                color = c;

            }
        }
    }
    return !emptyHit;
}

//

//-------------------------------------
//- UTILITY

float sdot(float3 x, float3 y, float f = 1.0f)
{
    return saturate(dot(x, y) * f);
}

float energy(float3 color)
{
    return dot(color, 1.0f / 3.0f);
}

//-------------------------------------
//- RANDOMNESS

float2 _Pixel;
float _Seed;

float rand()
{
    float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
    _Seed += 1.0f;
    return result;
}


//-------------------------------------
//- SPHERES

struct Sphere
{
    float3 position;
    float radius;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

StructuredBuffer<Sphere> _Spheres;

struct BlackHole
{
    float3 position;
    float radius;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

StructuredBuffer<BlackHole> _BlackHoles;

float3 rodrigez(float3 v, float3 k, float angle)
{
    k = normalize(k);
    float3 a0 = v * cos(angle);
    float3 a1 = cross(k, v) * sin(angle);
    float3 a2 = k * dot(k, v) * (1.0f - cos(angle));
    return a0 + a1 + a2;
}
//-------------------------------------
//- RAY

struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}


//-------------------------------------
//- RAYHIT

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.albedo = float3(0.0f, 0.0f, 0.0f);
    hit.specular = float3(0.0f, 0.0f, 0.0f);
    hit.smoothness = 0.0f;
    hit.emission = float3(0.0f, 0.0f, 0.0f);
    return hit;
}


//-------------------------------------
//- INTERSECTION
float shadowLimiter;

void IntersectGroundPlane(Ray ray, inout RayHit bestHit)
{
    // Calculate distance along the ray where the ground plane is intersected
    float t = -ray.origin.y / ray.direction.y;
    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = float3(0.0f, 1.0f, 0.0f);
        bestHit.albedo = float3(1.0f, 1.0f, 1.0f);
        bestHit.specular = float3(1.0f, 1.0f, 1.0f);
        bestHit.smoothness = 1.0f;
        bestHit.emission = float3(0.0f, 0.0f, 0.0f);
    }
}

void IntersectSphere(Ray ray, inout RayHit bestHit, Sphere sphere)
{
    // Calculate distance along the ray where the sphere is intersected
    float3 d = ray.origin - sphere.position;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = normalize(bestHit.position - sphere.position);
        bestHit.albedo = sphere.albedo;
        bestHit.specular = sphere.specular;
        bestHit.smoothness = sphere.smoothness;
        bestHit.emission = sphere.emission;
    }
}

void IntersectBlackHole0(Ray ray, inout RayHit bestHit, BlackHole blackHole)
{   

    // Calculate distance along the ray where the sphere is intersected
    float m = blackHole.radius;
    
    float3 dd = -(ray.origin - blackHole.position);
    float dsc = length(dd);

    float3 nd = normalize(dd);
    float3 no = normalize(ray.direction);

    float wsp = dot(nd, no);

    float b = dsc * wsp;

    float t = b;

    float3 bvec = no * b;

    float3 hitPoint = ray.origin + bvec;

    float3 k = cross(ray.direction, dd);

    float3 a = (b - dd);

    float a_l = length(hitPoint) - 6 * m;

    float angle = 4.0f * m / a_l;

    angle = angle / 2.0f + PI / 2.0f;

    float3 rod_out = rodrigez(ray.direction, k, angle);
    rod_out = normalize(rod_out);
    
    if (t > 0 && t < bestHit.distance)
    {
        /*bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = float3(0.0f, 1.0f, 0.0f);
        bestHit.albedo = float3(0.0f, 0.0f, 0.0f);
        bestHit.specular = float3(1.0f, 1.0f, 1.0f);
        bestHit.smoothness = 1.0f;
        bestHit.emission = float3(0.0f, 0.0f, 0.0f);*/
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = rod_out; //normalize(bestHit.position - blackHole.position);
        bestHit.albedo = blackHole.albedo;
        bestHit.specular = blackHole.specular;
        bestHit.smoothness = blackHole.smoothness;
        bestHit.emission = blackHole.emission;
    }
    if (a_l < 0)
    {
        bestHit.normal = float3(0, 0, 0); //normalize(bestHit.position - blackHole.position);
    }

    /*float3 d = ray.origin - blackHole.position;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + blackHole.radius * blackHole.radius;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;*/
}

float getAngle2(float3 a, float3 b)
{
    return acos(clamp(dot(normalize(a), normalize(b)), -1, 1)) * 180.0 / PI;
}

float getPFMpixel(int x, int y)
{
    if (x < 0) 
        x = 0;
    if (x >= _textureWidth) 
        x = _textureWidth - 1;
    if (y < 0)
        y = 0;
    if (y >= _textureHeight)
        y = _textureHeight - 1;
    return _textureGravity[y * _textureWidth + x];
}

float getDerivativeX(int ix, int iy)
{
    return (getPFMpixel(ix + 1, iy) - getPFMpixel(ix - 1, iy)) / 2.0f;
}

float getDerivativeY(int ix, int iy)
{
    return (getPFMpixel(ix, iy + 1) - getPFMpixel(ix, iy - 1)) / 2.0f;
}

float getDerivativeXY(int ix, int iy)
{
    return (getPFMpixel(ix + 1, iy + 1) + getPFMpixel(ix - 1, iy - 1) - getPFMpixel(ix + 1, iy - 1) - getPFMpixel(ix - 1, iy + 1)) / 4.0f;
}

float getDerivativeXX(int ix, int iy)
{
    float derxl = (getPFMpixel(ix, iy) - getPFMpixel(ix - 2, iy)) / 2.0f;
    float derxr = (getPFMpixel(ix + 2, iy) - getPFMpixel(ix, iy)) / 2.0f;
    return (derxr - derxl) / 2.0f;
}

float getDerivativeYY(int ix, int iy)
{
    float deryu = (getPFMpixel(ix, iy) - getPFMpixel(ix, iy - 2)) / 2.0f;
    float deryd = (getPFMpixel(ix, iy + 2) - getPFMpixel(ix, iy)) / 2.0f;
    return (deryd - deryu) / 2.0f;
}

float getInterpolation(float x, float y)
{
    int ix = (int) x;
    int iy = (int) y;

    float xdiff = x - (float) ix;
    float ydiff = y - (float) iy;

    if (xdiff > 0.5f)
    {
        xdiff = -(1 - xdiff);
        ix++;
    }
    if (ydiff > 0.5f)
    {
        ydiff = -(1 - ydiff);
        iy++;
    }

    float derx = getDerivativeX(ix,iy);
    float dery = getDerivativeY(ix, iy);

    float derxy = getDerivativeXY(ix, iy);
    float deryx = derxy;

    float derxx = getDerivativeXX(ix, iy);
    float deryy = getDerivativeYY(ix, iy);

    float t0 = getPFMpixel(ix, iy);

    float t1 = (x - ix) * derx + (y - iy) * dery;

    float t2 = (1 / 2.0f) * ((x - ix) * (x - ix) * derxx + 2 * (x - ix) * (y - iy) * derxy + (y - iy) * (y-iy)*deryy);

    float derxxx = (getDerivativeXX(ix + 1, iy) - getDerivativeXX(ix - 1, iy)) / 2.0f;
    float deryyy = (getDerivativeYY(ix, iy - 1) - getDerivativeYY(ix, iy + 1)) / 2.0f;

    float derxxy = (getDerivativeXX(ix, iy + 1) - getDerivativeXX(ix, iy - 1)) / 2.0f;
    float deryyx = (getDerivativeXX(ix + 1, iy) - getDerivativeXX(ix - 1, iy)) / 2.0f;

    float derxyy = (getDerivativeXY(ix, iy + 1) - getDerivativeXY(ix, iy - 1)) / 2.0f;
    float derxyx = (getDerivativeXY(ix + 1, iy) - getDerivativeXY(ix - 1, iy)) / 2.0f;
    float deryxy = (getDerivativeXY(ix, iy + 1) - getDerivativeXY(ix, iy - 1)) / 2.0f;
    float deryxx = (getDerivativeXY(ix + 1, iy) - getDerivativeXY(ix - 1, iy)) / 2.0f;

    float t3 = (1 / 6.0f) * (
    ((x - ix) * (x - ix) * (x - ix) * derxxx) +
    ((x - ix) * (x - ix) * (y - iy) * derxxy) +
    ((x - ix) * (y - iy) * (x - ix) * derxyx) +
    ((x - ix) * (y - iy) * (y - iy) * derxyy) + 
    ((y - iy) * (x - ix) * (x - ix) * deryxx) + 
    ((y - iy) * (x - ix) * (y - iy) * deryxy) +
    ((y - iy) * (y - iy) * (x - ix) * deryyx) +
    ((y - iy) * (y - iy) * (y - iy) * deryyy));

    /*float2x2 dery;
    dery[0][0] = (neigh[1][2] - neigh[1][0]) / 2.0f;
    dery[0][1] = (neigh[1][3] - neigh[1][1]) / 2.0f;
    dery[1][0] = (neigh[2][2] - neigh[2][0]) / 2.0f;
    dery[1][1] = (neigh[2][3] - neigh[2][1]) / 2.0f;

    float2x2 derxy;
    derxy[0][0] = (neigh[2][2] - neigh[0][1] - neigh[1][0] + neigh[1][1]) / 4.0f;
    derxy[0][1] = (neigh[2][3] - neigh[0][2] - neigh[1][1] + neigh[1][2]) / 4.0f;
    derxy[1][0] = (neigh[3][2] - neigh[1][1] - neigh[2][0] + neigh[2][1]) / 4.0f;
    derxy[1][1] = (neigh[3][3] - neigh[1][2] - neigh[2][1] + neigh[2][2]) / 4.0f;*/

    return t0 + t1 + t2 + t3;
}

float getLinearInterpolation(float tx, float ty)
{
    int ix0 = (int) (tx - 0.5f);
    int iy0 = (int) (ty - 0.5f);
    int ix1 = ix0 + 1;
    int iy1 = iy0 + 1;

    float pix00;
    float pix01;
    float pix10;
    float pix11;

   
    pix00 = _textureGravity[iy0 * _textureWidth + ix0];
    pix01 = _textureGravity[iy0 * _textureWidth + ix1];
    pix10 = _textureGravity[iy1 * _textureWidth + ix0];
    pix11 = _textureGravity[iy1 * _textureWidth + ix1];
    


    pix00 = pix00 * pix00 * pix00 * pix00;
    pix01 = pix01 * pix01 * pix01 * pix01;
    pix10 = pix10 * pix10 * pix10 * pix10;
    pix11 = pix11 * pix11 * pix11 * pix11;

    if (pix01 >= shadowLimiter && pix11 >= shadowLimiter)
    {
        float d1 = (tx - (ix0 + 0.5f)) * (tx - (ix0 + 0.5f)) + (ty - (iy0 + 0.5f)) * (ty - (iy0 + 0.5f));
        float d2 = (tx - (ix1 + 0.5f)) * (tx - (ix1 + 0.5f)) + (ty - (iy1 + 0.5f)) * (ty - (iy1 + 0.5f));
        /*if (d1 < d2)
        {
            return shadowLimiter;
        }*/
    }

    float tmp0 = pix00 + (pix01 - pix00) * ((tx - (ix0 + 0.5f)) / ((ix1 + 0.5f) - (ix0 + 0.5f)));
    float tmp1 = pix10 + (pix11 - pix10) * ((tx - (ix0 + 0.5f)) / ((ix1 + 0.5f) - (ix0 + 0.5f)));
    float tmp3 = tmp0 + (tmp1 - tmp0) * ((ty - (iy0 + 0.5f)) / ((iy1 + 0.5f) - (iy0 + 0.5f)));
    //float tmp3 = pix00 + (pix10 - pix00) * ((ty - (iy0 + 0.5f)) / ((iy1 + 0.5f) - (iy0 + 0.5f)));
    //float tmp3 = pix10 + (pix11 - pix10) * ((tx - (ix0 + 0.5f)) / ((ix1 + 0.5f) - (ix0 + 0.5f)));
    return tmp3;
}

void IntersectBlackHole(Ray ray, inout RayHit bestHit, BlackHole blackHole)
{

    // Calculate distance along the ray where the sphere is intersected
    float m = blackHole.radius;
    float halfRadius = m / 2.0;
    
    float3 dd = -(ray.origin - blackHole.position);
    float dsc = length(dd);

    float3 nd = normalize(dd);
    float3 no = normalize(ray.direction);

    float wsp = dot(nd, no);

    float b = dsc * wsp;

    float t = b;

    float3 bvec = no * b;

    float3 hitPoint = ray.origin + bvec;

    //
    //dd-odleglosc od czarnej dziury
    float3 dd2 = dd / halfRadius;
    //dd2 odleglosc w jednostkach metryki
    float angleWzg = getAngle2(dd2, ray.direction); //w stopniach
    float bb = length(dd2) * sin(angleWzg * PI / 180);

    float texturePositionX = 0;
    
    if (_axisMode == 0)
    {
        shadowLimiter = 4.4;
        float r = length(dd2);
        texturePositionX = sqrt(sqrt(r)) / 4.0; //wersja z R
    }
    else
    {
        shadowLimiter = 4.5;
        texturePositionX = sqrt(sqrt(bb)) / 4.0; //wersja z B
    }
    shadowLimiter = shadowLimiter * shadowLimiter * shadowLimiter * shadowLimiter;
    float texturePositionY = angleWzg / 180.0;

    float tx = texturePositionX * _textureWidth;
    float ty = texturePositionY * _textureHeight;

    float angler = 0;
    float resultt = 0;
    float resulttt = 0;
    float color = 0;
    
    if (tx >= 0 && tx < _textureWidth && ty >= 0 && ty < _textureHeight)
    {
        
        /*
        int x0 = (int)tx;
        int x1 = x0+1;
        float xdiff = tx - x0;
        int y0 = (int)ty;
        int y1 = y0 + 1;
        float ydiff = ty - y0;
        */

        
        /*float partx = tx - (int) tx;
        float party = ty - (int) ty;

        int x0, x1, y0, y1;

        if (partx >= 0.5f && party >= 0.5f)
        {
            x0 = (int)tx;
            y0 = (int)ty;
            x1 = x0 + 1;
            y1 = y0 + 1;
        }
        else if (partx < 0.5f && party < 0.5f)
        {
            x0 = (int) tx-1;
            y0 = (int) ty-1;
            x1 = x0 + 1;
            y1 = y0 + 1;
        }
        else if (partx >= 0.5f && party < 0.5f)
        {
            x0 = (int) tx;
            y0 = (int) ty-1;
            x1 = x0 + 1;
            y1 = y0 + 1;
        }
        else if (partx < 0.5f && party >= 0.5f)
        {
            x0 = (int) tx-1;
            y0 = (int) ty;
            x1 = x0 + 1;
            y1 = y0 + 1;
        }*/
        /*int x0 = (int) (tx - 0.5f);
        int y0 = (int) (ty - 0.5f);
        int x1 = x0 + 1;
        int y1 = y0 + 1;

        float xdiff = tx - (x0 + 0.5f);
        float ydiff = ty - (y0 + 0.5f);*/

        int x0 = (int)tx;
        int x1 = x0 + 1;
        float xdiff = tx - x0;
        int y0 = (int)ty;
        int y1 = y0 + 1;
        float ydiff = ty - y0;

        if (_interpolationMode == 0)
        {
            //brak interpolacji
            color = _textureGravity[y0 * _textureWidth + x0];
            color = color * color * color * color;

        }
        if (_interpolationMode == 3)
        {
            //szereg taylora
            color = getInterpolation(tx, ty);
        }
        float pix00;
        float pix01;
        float pix10;
        float pix11;
            //interpolacja liniowa
        
        pix00 = _textureGravity[y0 * _textureWidth + x0];
        pix01 = _textureGravity[y0 * _textureWidth + x1];
        pix10 = _textureGravity[y1 * _textureWidth + x0];
        pix11 = _textureGravity[y1 * _textureWidth + x1];
        
        if (_interpolationMode == 1)
        {
            /*pix00 = pix00 * pix00 * pix00 * pix00;
            pix01 = pix01 * pix01 * pix01 * pix01;
            pix10 = pix10 * pix10 * pix10 * pix10;
            pix11 = pix11 * pix11 * pix11 * pix11;*/

            //float par0 = pix00 + (pix01 - pix00) * xdiff;
            //float par1 = pix10 + (pix11 - pix10) * xdiff;
            
            //color = par0 + (par1 - par0) * ydiff;
            //color = color * color * color * color;
            color = getLinearInterpolation(tx, ty);
            //color = 10;

        }

        if (x1 + 1 < _textureWidth && y1 + 1 < _textureHeight && x0 - 1 >= 0 && y0 - 1 >= 0 && _interpolationMode == 2)
        {
            //interpolacja bikubiczna
            float4x4 neigh;
            for (int x = x0 - 1, i = 0; i < 4; ++i, ++x)
            {
                for (int y = y0 - 1, j = 0; j < 4; ++j, ++y)
                {
                    
                    neigh[i][j] = _textureGravity[y * _textureWidth + x] * _textureGravity[y * _textureWidth + x] * _textureGravity[y * _textureWidth + x] * _textureGravity[y * _textureWidth + x];
                }
            }

            float2x2 derx;
            derx[0][0] = (neigh[2][1] - neigh[0][1]) / 2.0f;
            derx[0][1] = (neigh[2][2] - neigh[0][2]) / 2.0f;
            derx[1][0] = (neigh[3][1] - neigh[1][1]) / 2.0f;
            derx[1][1] = (neigh[3][2] - neigh[1][2]) / 2.0f;

            float2x2 dery;
            dery[0][0] = (neigh[1][2] - neigh[1][0]) / 2.0f;
            dery[0][1] = (neigh[1][3] - neigh[1][1]) / 2.0f;
            dery[1][0] = (neigh[2][2] - neigh[2][0]) / 2.0f;
            dery[1][1] = (neigh[2][3] - neigh[2][1]) / 2.0f;

            float2x2 derxy;
            derxy[0][0] = (neigh[2][2] - neigh[0][2] - neigh[2][0] + neigh[0][0]) / 4.0f;
            derxy[0][1] = (neigh[2][3] - neigh[0][3] - neigh[2][1] + neigh[0][1]) / 4.0f;
            derxy[1][0] = (neigh[3][2] - neigh[1][2] - neigh[3][0] + neigh[1][0]) / 4.0f;
            derxy[1][1] = (neigh[3][3] - neigh[1][3] - neigh[3][1] + neigh[1][1]) / 4.0f;

            float4x4 mata;
            mata[0][0] = neigh[0][0];
            mata[0][1] = neigh[0][1];
            mata[1][0] = neigh[1][0];
            mata[1][1] = neigh[1][1];

            mata[0][2] = dery[0][0];
            mata[0][3] = dery[0][1];
            mata[1][2] = dery[1][0];
            mata[1][3] = dery[1][1];

            mata[2][0] = derx[0][0];
            mata[2][1] = derx[0][1];
            mata[3][0] = derx[1][0];
            mata[3][1] = derx[1][1];

            mata[2][2] = derxy[0][0];
            mata[2][3] = derxy[0][1];
            mata[3][2] = derxy[1][0];
            mata[3][3] = derxy[1][1];

            float4x4 Lmatrix;
            Lmatrix[0][0] = 1;
            Lmatrix[0][1] = 0;
            Lmatrix[0][2] = 0;
            Lmatrix[0][3] = 0;

            Lmatrix[1][0] = 0;
            Lmatrix[1][1] = 0;
            Lmatrix[1][2] = 1;
            Lmatrix[1][3] = 0;

            Lmatrix[2][0] = -3;
            Lmatrix[2][1] = 3;
            Lmatrix[2][2] = -2;
            Lmatrix[2][3] = -1;

            Lmatrix[3][0] = 2;
            Lmatrix[3][1] = -2;
            Lmatrix[3][2] = 1;
            Lmatrix[3][3] = 1;

            float4x4 Rmatrix;
            Rmatrix[0][0] = 1;
            Rmatrix[0][1] = 0;
            Rmatrix[0][2] = -3;
            Rmatrix[0][3] = 2;

            Rmatrix[1][0] = 0;
            Rmatrix[1][1] = 0;
            Rmatrix[1][2] = 3;
            Rmatrix[1][3] = -2;

            Rmatrix[2][0] = 0;
            Rmatrix[2][1] = 1;
            Rmatrix[2][2] = -2;
            Rmatrix[2][3] = 1;

            Rmatrix[3][0] = 0;
            Rmatrix[3][1] = 0;
            Rmatrix[3][2] = -1;
            Rmatrix[3][3] = 1;

            float4x4 Amatrix = mul(mul(Lmatrix, mata), Rmatrix);

            float1x4 Lx;
            Lx[0][0] = 1;
            Lx[0][1] = xdiff;
            Lx[0][2] = xdiff * xdiff;
            Lx[0][3] = xdiff * xdiff * xdiff;
            
            float4x1 Ry;
            Ry[0][0] = 1;
            Ry[1][0] = ydiff;
            Ry[2][0] = ydiff * ydiff;
            Ry[3][0] = ydiff * ydiff * ydiff;

            color = mul(mul(Lx, Amatrix),Ry)[0][0];
        }
        else if (x1 < _textureWidth && y1 < _textureHeight && x0 >= 0 && y0 >= 0 && _interpolationMode == 2)
        {
            //interpolacja liniowa
            float par0 = pix00 + (pix01 - pix00) * xdiff;
            float par1 = pix10 + (pix11 - pix10) * xdiff;
            color = par0 + (par1 - par0) * ydiff;
        }

        
    }
    //miesci sie w zakresie
    //color = _FloatTexture.SampleLevel(sampler_FloatTexture, float2(texturePositionX*1000.0, texturePositionY*1000.0), 0).x;
    //int3 loc = (10,10,1);
    //color = _FloatTexture.Load(loc);
    //if (color != 0) color = 2;
        //return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    resultt = color;
    //resultt = color * color * color * color;
    //resultt = resultt * PI / 180.0;

    angler = resultt * PI / 180.0;

    //dziala, stare
    float3 k = cross(ray.direction, dd);
    float3 a = (b - dd);
    float a_l = length(hitPoint) - 6 * m;
    //angle = 4.0f * m / a_l;
    
    angler = angler / 2.0f + PI / 2.0f;

    float3 rod_out = rodrigez(ray.direction, k, angler);
    rod_out = normalize(rod_out);
    
    //if (t > 0 && t < bestHit.distance)
    if (t < bestHit.distance)
    {
        /*bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = float3(0.0f, 1.0f, 0.0f);
        bestHit.albedo = float3(0.0f, 0.0f, 0.0f);
        bestHit.specular = float3(1.0f, 1.0f, 1.0f);
        bestHit.smoothness = 1.0f;
        bestHit.emission = float3(0.0f, 0.0f, 0.0f);*/
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = rod_out; //normalize(bestHit.position - blackHole.position);
        bestHit.albedo = blackHole.albedo;
        bestHit.specular = blackHole.specular;
        bestHit.smoothness = blackHole.smoothness;
        bestHit.emission = blackHole.emission;
    }
    if (a_l < 0)
    {
        //bestHit.normal = float3(0, 0, 0); //normalize(bestHit.position - blackHole.position);
    }
    if (resultt >= shadowLimiter)
    {
        bestHit.normal = float3(0, 0, 0); //odpowiada za czarny kolor
    }

    /*float3 d = ray.origin - blackHole.position;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + blackHole.radius * blackHole.radius;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;*/
}

//-------------------------------------
//- TRACE

RayHit Trace(Ray ray)
{
    RayHit bestHit = CreateRayHit();

    // Trace ground plane
    //IntersectGroundPlane(ray, bestHit);

    // Trace spheres
    uint numSpheres, numBlackHoles, stride;
    _Spheres.GetDimensions(numSpheres, stride);
    for (uint i = 0; i < numSpheres; i++)
        IntersectSphere(ray, bestHit, _Spheres[i]);
    
    return bestHit;
}


RayHit BlackTrace(Ray ray)
{
    RayHit bestHit = CreateRayHit();

    // Trace ground plane
    //IntersectGroundPlane(ray, bestHit);

    // Trace spheres
    uint numSpheres, numBlackHoles, stride;
    _BlackHoles.GetDimensions(numBlackHoles, stride);
    for (uint j = 0; j < numBlackHoles; j++)
        IntersectBlackHole(ray, bestHit, _BlackHoles[j]);
    
    return bestHit;
}

//-------------------------------------
//- SAMPLING

float3x3 GetTangentSpace(float3 normal)
{
    // Choose a helper vector for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);

    // Generate vectors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal, float alpha)
{
    // Sample the hemisphere, where alpha determines the kind of the sampling
    float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    float phi = 2 * PI * rand();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);

    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

//-------------------------------------
//- SHADE

float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}

float3 ref2(float3 d, float3 n)
{
    return d-2*dot(d,n)*n;
}

float3 Shade(inout Ray ray, RayHit hit)
{   
    if (hit.distance < 1.#INF)
    {
        // Calculate chances of diffuse and specular reflection
        hit.albedo = min(1.0f - hit.specular, hit.albedo);
        float specChance = energy(hit.specular);
        float diffChance = reflect(ray.direction, hit.normal);


        /*ray.origin = hit.position + hit.normal * 0.001f;
        ray.direction = ray.direction;
        ray.energy *= 1.0f;*/

        // Specular reflection
        ray.origin = hit.position + hit.normal * 0.001f;
        float alpha = SmoothnessToPhongAlpha(hit.smoothness);
        //ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
        ray.direction = ref2(ray.direction, hit.normal);
            //ray.direction = reflect(ray.direction, hit.normal);
        float f = (alpha + 2) / (alpha + 1);
        //ray.energy *= (1.0f / specChance) * hit.specular * sdot(hit.normal, ray.direction, f);
        ray.energy *= 1.0f;        

        if (length(hit.normal) == 0)
        {
            ray.energy *= 0.0f;
        }

        return hit.emission;

        // Roulette-select the ray's path
        float roulette = rand();
        if (roulette < specChance)
        {
            // Specular reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            float alpha = SmoothnessToPhongAlpha(hit.smoothness);
            ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
            //ray.direction = reflect(ray.direction, hit.normal);
            float f = (alpha + 2) / (alpha + 1);
            ray.energy *= (1.0f / specChance) * hit.specular * sdot(hit.normal, ray.direction, f);
        }
        else if (diffChance > 0 && roulette < specChance + diffChance)
        {
            // Diffuse reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            ray.direction = SampleHemisphere(hit.normal, 1.0f);
            ray.energy *= (1.0f / diffChance) * hit.albedo;
        }
        else
        {
            // Terminate ray
            ray.energy = 0.0f;
        }

        return hit.emission;
    }
    else
    {
        // Erase the ray's energy - the sky doesn't reflect anything
        ray.energy = 0.0f;

        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}

/*float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.distance < 1.#INF)
    {
        // Calculate chances of diffuse and specular reflection
        hit.albedo = min(1.0f - hit.specular, hit.albedo);
        float specChance = energy(hit.specular);
        float diffChance = energy(hit.albedo);

        // Roulette-select the ray's path
        float roulette = rand();
        if (roulette < specChance)
        {
            // Specular reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            float alpha = SmoothnessToPhongAlpha(hit.smoothness);
            ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
            //ray.direction = reflect(ray.direction, hit.normal);
            float f = (alpha + 2) / (alpha + 1);
            ray.energy *= (1.0f / specChance) * hit.specular * sdot(hit.normal, ray.direction, f);
        }
        else if (diffChance > 0 && roulette < specChance + diffChance)
        {
            // Diffuse reflection
            ray.origin = hit.position + hit.normal * 0.001f;
            ray.direction = SampleHemisphere(hit.normal, 1.0f);
            ray.energy *= (1.0f / diffChance) * hit.albedo;
        }
        else
        {
            // Terminate ray
            ray.energy = 0.0f;
        }

        return hit.emission;
    }
    else
    {
        // Erase the ray's energy - the sky doesn't reflect anything
        ray.energy = 0.0f;

        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}*/


//-------------------------------------
//- KERNEL

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    _Pixel = id.xy;
    //Result[id.xy] = float4(1, 1, 0, 0);
    //return;
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);

    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);

    float4 test_c;
    float3 test_h;
    //dodac wektor normalny
    bool test_b = rayMeshCollisionChecker(ray.origin, ray.direction, test_c, test_h);

    if (test_b)
    {
        Result[id.xy] = test_c;
        return;
    }

    // Trace and shade the ray
    float3 result = float3(0, 0, 0);   
    RayHit hit;

    hit = BlackTrace(ray);
    result += ray.energy * Shade(ray, hit);

    for (int i = 0; i < 10; i++)
    {
        hit = Trace(ray);
        result += ray.energy * Shade(ray, hit);

        if (!any(ray.energy))
            break;
    }
    

    Result[id.xy] = float4(result, 1);
}
