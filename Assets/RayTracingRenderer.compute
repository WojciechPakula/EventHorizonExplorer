// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> DEBoutput;

RWTexture2D<float4> Result;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float4 _DirectionalLight;

float2 _PixelOffset;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

//limiter
int _rayLimit;

//gravity lensing
StructuredBuffer<float> _textureGravity;
int _textureWidth;
int _textureHeight;
StructuredBuffer<float> _textureGravityFar;
int _textureWidthFar;

static const float PI = 3.14159265f;

//3D mesh
struct SubMeshMaterial
{
    int sub;
    int textureId;
    float4 c;
    float2 tiling;
    float2 offset;
};
struct TransformPack
{
    int meshId;
    float3 position;
    float4 rotation;
    float3 scale;
};
StructuredBuffer<float3> _static_V;
StructuredBuffer<float3> _static_N;
StructuredBuffer<float2> _static_UV;
StructuredBuffer<int3> _static_T;
StructuredBuffer<float3> _static_B;
StructuredBuffer<int3> _static_bvh;
StructuredBuffer<SubMeshMaterial> _static_SUB2;
StructuredBuffer<int> _static_IND;

StructuredBuffer<TransformPack> _static_transforms;

//textures
StructuredBuffer<float4> _static_Textures;
StructuredBuffer<int3> _static_Textures_IND; //table start index, width, height

//GRAVITY
struct BlackHole
{
    float3 position;
    float rs;
};
StructuredBuffer<BlackHole> _BlackHoles;
int _bhCount;

BlackHole createBlackHole()
{
    BlackHole bh;
    bh.position = float3(0,0,0);
    bh.rs = 0;
    return bh;
}

//-------------------------------------
//- RANDOMNESS

float2 _Pixel;
float _Seed;

float rand()
{
    float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
    _Seed += 1.0f;
    return result;
}

float4 getPixel(float2 UV, SubMeshMaterial mat)
{
    int3 dat = _static_Textures_IND[mat.textureId];
    //int3 dat = _static_Textures_IND[2]; //debug
    int t_ = dat.x; //index
    int w = dat.y; //width
    int h = dat.z; //height

    float2 UV2 = UV * mat.tiling + mat.offset;

    UV2.x = (UV2.x - (int) UV2.x);
    UV2.y = (UV2.y - (int) UV2.y);

    float2 pos = float2(UV2.x * (float) w, UV2.y * (float) h);

    int2 posInt = int2((int) pos.x, (int) pos.y);

    float4 col = _static_Textures[t_ + (posInt.y * w + posInt.x)];
    return col;
}
//

//-------------------------------------
//- PRZECIĘCIE TRÓJKĄTA
bool rayTriangleCheck(float3 rayOrigin,
                           float3 rayVector,
                           float3 vertex0,
                           float3 vertex1,
                           float3 vertex2,
                           out float3 outIntersectionPoint)
{
    outIntersectionPoint = float3(0, 0, 0);

    float EPSILON = 0.0000001f;
    float3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    if (a > -EPSILON && a < EPSILON)
        return false; // This ray is parallel to this triangle.
    f = 1.0f / a;
    s = rayOrigin - vertex0;
    u = f * (dot(s, h));
    if (u < 0.0 || u > 1.0)
        return false;
    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    if (v < 0.0 || u + v > 1.0)
        return false;
        // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON) // ray intersection
    {
        outIntersectionPoint = rayOrigin + rayVector * t;
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}

//- PRZECIĘCIE BOXA
float max3(float a, float b, float c)
{
    return max(a, max(b, c));
}
float min3(float a, float b, float c)
{
    return min(a, min(b, c));
}

bool rayBoxCheck(float3 p, float3 d, float3 a, float3 A, out float distance)
{
    distance = 1.#INF;
    float t1 = (a.x - p.x) / d.x;
    float t2 = (A.x - p.x) / d.x;
    float t3 = (a.y - p.y) / d.y;
    float t4 = (A.y - p.y) / d.y;
    float t5 = (a.z - p.z) / d.z;
    float t6 = (A.z - p.z) / d.z;
    float tmin = max3(min(t1, t2), min(t3, t4), min(t5, t6));
    float tmax = min3(max(t1, t2), max(t3, t4), max(t5, t6));
    if (tmax < 0)
        return false;
    else if (tmin > tmax)
        return false;
    distance = tmin;
    return true;
}
//WYKRYWANIE OBIEKTOW
bool BVHsearch(float3 origin_, float3 direction_, float rayLength, float3 scale, int bvh_, int b_, int t_, int v_, int s_, int s_c, out float3 output, out float4 color, out float3 normal)
{
    int stos[100];
    int stosIndex = 0;

    int bvhindex = 0;
    int lastindex = 0;

    bool stopCondition = false;

    bool emptyHit = true;
    float3 bestHit = float3(0, 0, 0);
    float bestHitDist = 9999999;
    int bestTriangleId = 0;

    //int loopLimiter = 100000;//duża wartosc
    int loopLimiter = 10000; //duża wartosc

    while (true)
    {
        loopLimiter--;
        if (loopLimiter <= 0)
            break;

        stos[stosIndex] = bvhindex;
        int currentIndex = bvhindex;
        int3 node = _static_bvh[bvhindex + bvh_];

        if (node.y == 0 && node.z == 0)
        {
            //triangle
            float3 trOutput;
            bool res = rayTriangleCheck(origin_, direction_, _static_V[_static_T[node.x + t_].x + v_] * scale, _static_V[_static_T[node.x + t_].y + v_] * scale, _static_V[_static_T[node.x + t_].z + v_] * scale, trOutput);
        
            if (res)
            {
                float f = length(trOutput - origin_);
                if (emptyHit == true || f < bestHitDist)
                {
                    emptyHit = false;
                    bestHitDist = f;
                    bestHit = trOutput;
                    bestTriangleId = node.x;
                }
            }

            //w gore
            stosIndex--;
            if (stosIndex < 0)
                break;
            bvhindex = stos[stosIndex];
        }
        else
        {
            //check collision
            //box
            if (lastindex != node.y && lastindex != node.z)
            {
                float boxDist;
                bool res = rayBoxCheck(origin_, direction_, _static_B[node.x + b_] * scale, _static_B[node.x + b_ + 1] * scale, boxDist);
                //if (res && boxDist > rayLength && rayLength != 1.#INF)
                //    res = false;
                if (res && boxDist > rayLength)
                    res = false;
                if (res)
                {
                    //wejdz w lewy
                    bvhindex = node.y;
                    stosIndex++;
                }
                else
                {
                    stosIndex--;
                    if (stosIndex < 0)
                        break;
                    bvhindex = stos[stosIndex];
                }
            }
            else if (lastindex == node.y)
            {
                //wejdz w prawy
                bvhindex = node.z;
                stosIndex++;
            }
            else if (lastindex == node.z)
            {
                //wroc w gore
                stosIndex--;
                if (stosIndex < 0)
                    break;
                bvhindex = stos[stosIndex];
            }
        }
        lastindex = currentIndex;
    }
    //koniec petli
    output = bestHit;
    color = float4(1, 1, 0, 0);
    if (!emptyHit && true)
    {
        //trafienie
        //int3 tr = _static_T[ bestTriangleId+t_];
        SubMeshMaterial mat;
        if (s_c == 1)//DEBUG
        {
            mat = _static_SUB2[s_];
        }
        else if (s_c > 1)
        {
            for (int i = s_c - 1; i >= 0; --i)
            {
                SubMeshMaterial mat0 = _static_SUB2[s_ + i];
                if (bestTriangleId >= mat0.sub)
                {
                    mat = mat0;
                    break;
                }
            }
        }

        int3 tr = _static_T[t_ + bestTriangleId];
        float3 Ce = bestHit;
        float3 A = _static_V[v_ + tr.x] * scale;
        float3 B = _static_V[v_ + tr.y] * scale;
        float3 C = _static_V[v_ + tr.z] * scale;
        float3 A_diff = (B - A);
        float3 B_diff = (C - B);
        float3 C_diff = (A - C);
            
        float P0 = length(cross(A_diff, C_diff)) / 2.0f;

        float PC = length(cross(A_diff, (Ce - A)) / 2.0f) / P0;
        float PA = length(cross(B_diff, (Ce - B)) / 2.0f) / P0;
        float PB = length(cross(C_diff, (Ce - C)) / 2.0f) / P0;
        normal = _static_N[v_ + tr.x] * PA + _static_N[v_ + tr.y] * PB + _static_N[v_ + tr.z] * PC;
        if (mat.textureId == -1)
        {
            color = mat.c;
        }
        else
        {
            color = mat.c;

            float2 UVA = _static_UV[v_ + tr.x];
            float2 UVB = _static_UV[v_ + tr.y];
            float2 UVC = _static_UV[v_ + tr.z];

            float2 UV = (UVA * PA) + (UVB * PB) + (UVC * PC);

            //normal Vector
            normal = _static_N[v_ + tr.x] * PA + _static_N[v_ + tr.y] * PB + _static_N[v_ + tr.z] * PC;

            color = getPixel(UV, mat);
            //color = float4(PA, PB, PC, 0);
        }
    }
    return !emptyHit;
}

float4 quaternionInv(float4 q)
{
    float sum = q.x * q.x +
        q.y * q.y +
        q.z * q.z +
        q.w * q.w;
    return float4(-q.x / sum, -q.y / sum, -q.z / sum, q.w / sum);
}
float4 quaternionCross(float4 q, float4 r)
{
    float t0 = q.x * r.x - q.y * r.y - q.z * r.z - q.w * r.w;
    float t1 = q.y * r.x + q.x * r.y - q.w * r.z + q.z * r.w;
    float t2 = q.z * r.x + q.w * r.y + q.x * r.z - q.y * r.w;
    float t3 = q.w * r.x - q.z * r.y + q.y * r.z + q.x * r.w;
    return float4(t0, t1, t2, t3);
}
float3 vectorQRotation(float3 v, float4 q)
{
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;
    float3 m1 = float3(1 - 2 * y * y - 2 * z * z, 2 * x * y - 2 * z * w, 2 * x * z + 2 * y * w);
    float3 m2 = float3(2 * x * y + 2 * z * w, 1 - 2 * x * x - 2 * z * z, 2 * y * z - 2 * x * w);
    float3 m3 = float3(2 * x * z - 2 * y * w, 2 * y * z + 2 * x * w, 1 - 2 * x * x - 2 * y * y);

    return float3(dot(m1, v), dot(m2, v), dot(m3, v));
}
//-------------------------------------
//- RAYHIT

struct RayHit
{
    float3 position;
    float3 normal;
    float4 emission;
    float distance;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.emission = float4(0.0f, 0.0f, 0.0f, 1.0f);
    hit.distance = 1.#INF;
    return hit;
}
//-------------------------------------
//- RAY

struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
    float length;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    ray.length = 1.#INF;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}
bool rayMeshCollisionChecker(Ray ray, out RayHit rh)
{
    //color = float4(0, 0, 0, 1);
    //color = float4(direction.x * direction.x + origin.x / 100.0f, direction.y * direction.y + origin.y / 100.0f, direction.z * direction.z + origin.z / 100.0f, 1);
    //outHitPoint = float3(0, 0, 0);

    float3 direction = ray.direction;
    float3 origin = ray.origin;

    rh = CreateRayHit();
    uint numObj, stride;
    _static_transforms.GetDimensions(numObj, stride);


    bool emptyHit = true;
    float mind = 0;
    for (uint i = 0; i < numObj; ++i)//killer
    {
        TransformPack obj = _static_transforms[i];

        float4 invRotation = quaternionInv(obj.rotation);
        float3 diff = origin - obj.position;
        
        float3 origin_ = vectorQRotation(diff, invRotation);
        float3 direction_ = vectorQRotation(direction, invRotation);

        //color = float4(direction_.x * direction_.x + origin_.x / 100.0f, direction_.y * direction_.y + origin_.y / 100.0f, direction_.z * direction_.z + origin_.z / 100.0f, 1);
    

        int index = obj.meshId * 6;

        int id = _static_IND[index + 0];
        int bvh = _static_IND[index + 1];
        int b = _static_IND[index + 2];
        int t = _static_IND[index + 3];
        int v = _static_IND[index + 4];
        int s = _static_IND[index + 5];
        int id_, bvh_, b_, t_, v_, s_;

        int IND_size;
        _static_IND.GetDimensions((uint) IND_size, stride);
        int Statics_count = IND_size / 6;


        if (obj.meshId < Statics_count - 1)
        {
            index += 6;
            bvh_ = _static_IND[index + 1];
            b_ = _static_IND[index + 2];
            t_ = _static_IND[index + 3];
            v_ = _static_IND[index + 4];
            s_ = _static_IND[index + 5];
        }
        else
        {
            _static_bvh.GetDimensions((uint) bvh_, stride);
            _static_B.GetDimensions((uint) b_, stride);
            _static_T.GetDimensions((uint) t_, stride);
            _static_V.GetDimensions((uint) v_, stride);
            _static_SUB2.GetDimensions((uint) s_, stride);
        }

        float3 hitpoint;
        float4 c;
        float3 normal;

        bool hit = BVHsearch(origin_, direction_, ray.length, obj.scale, bvh, b, t, v, s, (s_ - s), hitpoint, c, normal);

        if (hit)
        {
            //emptyHit = false;
            //color = float4(1, 0.5f, 0.5f, 1);
            float d = distance(origin_, hitpoint);
            if (d < mind || emptyHit)
            {
                mind = d;
                hitpoint = vectorQRotation(hitpoint, obj.rotation);
                hitpoint += obj.position;
                //outHitPoint = hitpoint;
                emptyHit = false;
                //color = float4(0.0f, 1.0f, 0.5f, 1);
                //color = c;

                rh.emission = c;
                rh.normal = normal;
                rh.position = hitpoint;
                rh.distance = d;
            }
        }
    }
    return !emptyHit;
}

//KONIEC KODU DOTYCZĄCEGO OBIEKTÓW 3D



Ray rayQueue[100];
int qHead=0;
int qTail=0;
int qSize=0;

void PushRay(Ray ray)
{
    rayQueue[qTail] = ray;
    ++qTail;
    ++qSize;
}
bool PopRay(out Ray ret)
{
    if (qHead == qTail)
    {
        //error
        Ray ray;
        ret = ray;
        return false;
    }
    else
    {
        ret = rayQueue[qHead];
        ++qHead;
        --qSize;
        return true;
    } 
}


//
float angle(float3 a, float3 b)
{
    return acos(clamp(dot(normalize(a), normalize(b)), -1.0f, 1.0f));
}

float getApproachCollisionDistance(Ray ray, float3 pos)
{
    float3 tmp = pos - ray.origin;
    return length(tmp) * dot(normalize(ray.direction), normalize(tmp));
}
/*float getApproachCollisionDistance(Ray ray, float3 pos)
{
    float3 tmp = pos - ray.origin;
    float ret = length(tmp) * dot(normalize(ray.direction), normalize(tmp));
    return ret;
}*/
bool getSimpleBlackholeCollision(Ray ray, int mode, out BlackHole blackHole, out float d)
{
    uint count = 0;
    uint str = 0;
    _BlackHoles.GetDimensions(count,str);

    bool ret = false;
    d = 0;
    blackHole = createBlackHole();
    if (mode == -1)
    {
        float max = -9999999;
        for (uint i = 0; i < count; i++)
        {
            BlackHole bh = _BlackHoles[i];
            float a = getApproachCollisionDistance(ray, bh.position);
            if (a < 0 && a > max)
            {
                max = a;
                d = -max;
                blackHole = bh;
                ret = true;
            }
        }
    }
    else if (mode == 1)
    {
        float min = 9999999;
        for (uint i = 0; i < count; i++)
        {
            BlackHole bh = _BlackHoles[i];
            float a = getApproachCollisionDistance(ray, bh.position);
            if (a >= 0 && a < min)
            {
                min = a;
                d = min;
                blackHole = bh;
                ret = true;
            }
        }
    }
    return ret;
}
float3 crossUnity(float3 a, float3 b)
{
    return cross(a, b) * -1;
}
float3 rodrigez(float3 v, float3 k, float angle)
{
    if (angle == 0)
        return v;
    if (length(k) == 0)
        return v;
    k = normalize(k);
    float3 a0 = v * cos(angle);
    float3 a1 = crossUnity(k, v) * sin(angle);
    float3 a2 = k * dot(k, v) * (1.0f - cos(angle));
    return a0 + a1 + a2;
}
Ray bendRay(Ray ray, float3 position, float3 center, float angle)
{
    float3 bend = rodrigez(ray.direction, crossUnity(ray.direction, center - ray.origin), angle);
    Ray ret = CreateRay(position, bend);
    return ret;
}

float getTableNearest(float x, float y)
{
    return _textureGravity[_textureWidth * (int)y + (int)x];
}
float getTableLinear(float tx, float ty)
{
    int ix0 = (int) (tx - 0.5f);
    int iy0 = (int) (ty - 0.5f);
    int ix1 = ix0 + 1;
    int iy1 = iy0 + 1;

    float pix00;
    float pix01;
    float pix10;
    float pix11;

    pix00 = _textureGravity[iy0 * _textureWidth + ix0];
    pix01 = _textureGravity[iy0 * _textureWidth + ix1];
    pix10 = _textureGravity[iy1 * _textureWidth + ix0];
    pix11 = _textureGravity[iy1 * _textureWidth + ix1];

    float tmp0 = pix00 + (pix01 - pix00) * ((tx - (ix0 + 0.5f)) / ((ix1 + 0.5f) - (ix0 + 0.5f)));
    float tmp1 = pix10 + (pix11 - pix10) * ((tx - (ix0 + 0.5f)) / ((ix1 + 0.5f) - (ix0 + 0.5f)));
    float tmp3 = tmp0 + (tmp1 - tmp0) * ((ty - (iy0 + 0.5f)) / ((iy1 + 0.5f) - (iy0 + 0.5f)));
    return tmp3;
}

//x i y są od 0.0 do 1.0
float getTable(float x, float y, int mode)
{
    float x2 = _textureWidth * x;
    float y2 = _textureHeight * y;

    float ret = -1;

    if (x >= 1 || y >= 1)
    {
        //poza tekstura :(

    }
    else
    {
        if (mode == 0)
        {
            //nearest neighbour
            ret = getTableNearest(x2, y2);
        }
        else if (mode == 1)
        {
            //linear interpolation
            ret = getTableLinear(x2, y2);

        }
        else if (mode == 2)
        {
            //2

        }
    }
    return ret;
}
float getBlackHoleAngle(BlackHole bc, Ray ray, float addLength = 0)//zrobic!!!! ignoruje promien
{
    float unit = bc.rs / 2.0f;

    float beta = 0;
    ray.origin = ray.origin - ray.direction * addLength;
    float3 vr = bc.position - ray.origin;
    float alpha = angle(ray.direction, vr);
    float r = length(vr) / unit;

    float _x_r = sqrt(sqrt(r))/4.0f;
    float _y_alpha = alpha / PI;

    float tableOutput = 0;
    tableOutput = getTable(_x_r, _y_alpha,1);
    
    //method1
    if (tableOutput >= 6.0f)
        return 100;
    float beta0 = tableOutput * tableOutput * tableOutput * tableOutput * PI / 180.0f; //w radianach

    bool czarny = false;
    if (alpha < PI/2.0)
    {
        float app = r * sin(alpha);



        float b = app - 3;

        if (b < 0)
        {
            return 100;
            czarny = true;
        }

        float _farx = sqrt(sqrt(b))/4.0f;

        beta = (4.0f / b);
        if (_farx >= 0 && _farx < 1.0f)
        {
        //dobry zakres
            float _farx0 = _farx;
            _farx = _farx * _textureWidthFar;
            int zl = (int) _farx;
            int zh = zl + 1;

            float wsp = _farx - (float) zl;

            float val = 0;
            
            if (zl < _textureWidthFar && zh < _textureWidthFar)
            {
                float fl = _textureGravityFar[zl];
                float fh = _textureGravityFar[zh];

                val = fl * (1.0f - wsp) + fh * (wsp);

                if (fl < 0 && _x_r >= 0.9f)
                {
                //czarne
                    return 100;
                    czarny = true;
                }
            }
            if (_farx > 0.5f)
            {
                val = val * (1.0f - ((_farx0 - 0.5f)*2.0f));
            }
                
            b = b - val;
            //beta = (2.0*bc.rs / b);
            beta = (4.0f / b);
            //beta = 0.5f;
        }
        //_textureGravityFar[];
    }

    if (_x_r >= 0.9f && _x_r < 1.0f)
    {
        float ws = (_x_r - 0.9f)*10;
        beta = beta0 * (1.0f - ws) + beta * (ws);
    }
    if (_x_r < 0.9f)
        beta = beta0;
    if (_x_r >= 1.0f)
        beta = beta;
    
    return beta;
}

static float3 points[500];
static int pointCounter = 0;

bool Trace(out RayHit bestHit)
{
    int n = pointCounter;
    bestHit = CreateRayHit();

    float3 prev = points[0];

    uint numObj, stride;
    _BlackHoles.GetDimensions(numObj, stride);

    for (int i = 1; i < pointCounter; ++i)
    {
        float3 p = points[i];
        float len = length(p - prev);
        if (len > 0.0001f)
        {
            Ray tst;
            if (i + 1 == pointCounter)
            {
                len = 1.#INF;
                tst = CreateRay(prev, p);
                if (length(tst.direction) == 0)
                    break;

            }
            else
            {
                tst = CreateRay(prev, normalize(p - prev));
            }

            tst.length = len;
            RayHit rh;
            bool res = rayMeshCollisionChecker(tst, rh);
            //bool res = false;
            if (res)
            {
                //promien w cos uderzyl
                //ogranicznik
                bool fail = false;
                for (int g = 0; g < numObj; ++g)
                {
                    BlackHole a = _BlackHoles[g];
                    if (length(rh.position - a.position) < a.rs * 3)
                    {
                        fail = true;
                        break;
                    }
                }
                
                if (fail == false)
                {
                    bestHit = rh;
                    return true;
                }
            }
        }
        prev = p;
    }
    return false;
}

float3 getSkyboxPixel(Ray ray)
{
    // Sample the skybox and write it
    float theta = acos(ray.direction.y) / -PI;
    float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
    return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
}


void rayOperation(inout Ray ray)
{
    ray.energy = getSkyboxPixel(ray);
}
float4 Shade(inout Ray ray, RayHit hit)
{
    float4 ret = float4(0,0,0,0);
    if (hit.distance < 1.#INF && false)
    {
    }
    else{
        ray.energy = 0.0f;
        ret = float4(getSkyboxPixel(ray),1);
    }
    return ret;
}

float3 fullRayCalculation(Ray ray)
{
    int stosx[100];

}



void addPoint(float3 p)
{
    points[pointCounter] = p;
    pointCounter++;
}
void clearPoints()
{
    pointCounter = 0;
}
//rayPathMethod
float3 rotatePointAroundPoint(float3 p1, float3 c, float3 axis, float angle)
{
    return rodrigez(p1 - c, axis, angle) + c;
}
bool contains(int arr[100], int count, int element)
{
    for (int i = 0; i < count; ++i)
    {
        if (element == arr[i])
            return true;
    }
    return false;
}
float3 getAxis(Ray ray, float3 center)
{
    return normalize(crossUnity(ray.direction, center - ray.origin));
}
float3 projectOnPlane(float3 v, float3 planeNormal)
{
    return v - planeNormal * dot(v, planeNormal);
}
float angleAdvanced(float3 a, float3 b, float3 axis)
{
    a = normalize(projectOnPlane(a, axis));
    b = normalize(projectOnPlane(b, axis));

    float ang = angle(a, b);
    float3 cr = normalize(crossUnity(a, b));

    if (length(cr - axis) < 0.001)
    {
        return ang;
    }
    else
    {
        return 2 * PI - ang;
    }
}
float3 planeIntersection(float3 pointt, float3 normal, float3 origin, float3 direction)
{
    direction = normalize(direction);
    normal = normalize(normal);
    float3 normal2 = -1.0f * normal;

    float3 tmp = normal; //wybrac lepszy normal

    float kat = angle(direction, normal);
    if (kat <= PI / 2.0f)
        tmp = normal;
    else
        tmp = normal2;

    float alpha = PI / 2.0f - angle(origin - pointt, tmp);
    float beta = PI / 2.0f - angle(direction, tmp);

    float d = length(pointt-origin);
    float x = -d * sin(alpha) / sin(beta);

    return origin + direction * x;
}
void solveFullState(Ray ray, int bhInd, out float3 rot, out float3 v1, out float3 v2, out float3 v3)
{
    rot = float3(0, 0, 0);
    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = float3(0, 0, 0);
    
    float angle = getBlackHoleAngle(_BlackHoles[bhInd], ray);
    float3 axis = normalize(getAxis(ray, _BlackHoles[bhInd].position));
    float d = getApproachCollisionDistance(ray, _BlackHoles[bhInd].position);
    v1 = d * ray.direction;
    float3 hitBack = v1 + ray.origin;
    float3 hitFront = rotatePointAroundPoint(hitBack, _BlackHoles[bhInd].position, axis, angle);
    v2 = hitFront - hitBack;
    v3 = normalize(rodrigez(ray.direction, axis, angle));
    rot = axis * angle;
}
void solveMiddleState(Ray ray, int bhInd, out float3 rot, out float3 v1, out float3 v2, out float3 v3)
{
    rot = float3(0, 0, 0);
    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = float3(0, 0, 0);

    float angle = getBlackHoleAngle(_BlackHoles[bhInd], ray);
    float3 axis = normalize(getAxis(ray, _BlackHoles[bhInd].position));
    float3 rod1 = rodrigez(ray.direction, axis, angle / 2.0f);
    float d = getApproachCollisionDistance(ray, _BlackHoles[bhInd].position);

    float3 hitBack = planeIntersection(_BlackHoles[bhInd].position, ray.direction, ray.origin, rod1);
    float3 hitFront = rotatePointAroundPoint(hitBack, _BlackHoles[bhInd].position, axis, angle);

    v2 = hitFront - ray.origin;
    v3 = normalize(rodrigez(ray.direction, axis, angle));
    rot = axis * angle;
}
bool solveCrossVector(Ray ray, float3 rot, float3 v1, float3 v2, float3 v3, int forbidden[100], int forbiddenC, out Ray _ray2, out float3 _rot, out float3 _v1, out float3 _v2, out float3 _v3, out int choosenBH)
{
    float3 axis = normalize(rot); 
    float beta = length(rot);
    float3 startDir = ray.direction;
    float3 endDir = normalize(v3);
    float3 startPos = ray.origin + v1;
    float3 endPos = ray.origin + v1 + v2;
    float3 diff = endPos - startPos;

    _v1 = float3(0,0,0);
    _v2 = float3(0, 0, 0);
    _v3 = float3(0, 0, 0);
    _rot = float3(0, 0, 0);
    _ray2 = CreateRay(float3(0, 0, 0), float3(0, 0, 0));

    bool iscross = false;
    float outDMin = 1000;
    float3 choosenDir = float3(0, 0, 0);
    float3 choosenPos = float3(0, 0, 0);
    choosenBH = -1;

    uint c, s;
    _BlackHoles.GetDimensions(c,s);

    for (int i = 0; i < (int)c; ++i)
    {
        if (contains(forbidden, forbiddenC, i))
            continue;
        float3 nextBlackHole = _BlackHoles[i].position;

            /*Vector3 t0 = startPos - nextBlackHole;
            Vector3 t1 = endPos - nextBlackHole;

            Vector3 axis_advanced = Vector3.cross(t0, t1).normalized;*/

        float3 pos, dir;
        float outD;
            
            //metodaNewtona
        float epsilon = 0.08f;
        float x = 0.5f;
        float delta = 0;
        pos = float3(0, 0, 0);
        dir = float3(0, 0, 0);
        outD = 0;
        for (int j = 0; j < 10; ++j)
        {
            float3 d = rodrigez(startDir, axis, beta * x);
            float3 point1 = startPos + normalize(diff) * length(diff) * x;
            float3 tmp = point1 - nextBlackHole;
            float ang = angle(d, normalize(tmp));
            float _f = abs(cos(ang) * length(tmp));

            float dx = 0.0001f;

            float3 d2 = rodrigez(startDir, axis, beta * (x + dx));
            float3 point2 = startPos + normalize(diff) * length(diff) * (x + dx);
            float3 tmp2 = point2 - nextBlackHole;
            float ang2 = angle(d2, normalize(tmp2));
            float _f2 = abs(cos(ang2) * length(tmp2));

            float _fPrim = (_f2 - _f) / dx;
            float tmp3 = x - _f / _fPrim;
            delta = abs(tmp3 - x);
            x = tmp3;
            if (delta < epsilon)
            {
                break;
            }
        }
        if (delta < epsilon && x >= 0 && x <= 1)
        {
                //sukces
            outD = x;

                //pos = startPos + diff.normalized * diff.magnitude * x;
                //dir = getInterpolationDirection(startDir, axis, beta, x).normalized;
                
                //isSuccess = true;

            iscross = true;
            if (outD <= outDMin)
            {
                outDMin = outD;
                choosenDir = normalize(rodrigez(startDir, axis, beta * x));
                choosenPos = startPos + normalize(diff) * length(diff) * outD;
                choosenBH = i;
            }
        }
    }
    if (iscross)
    {
            //ustaw wyjscie
        _ray2 = CreateRay(choosenPos - choosenDir * (length(v1) + length(diff) * outDMin), choosenDir);
        float beta2 = getBlackHoleAngle(_BlackHoles[choosenBH], _ray2);
        float3 axis2 = normalize(crossUnity(choosenDir, _BlackHoles[choosenBH].position - choosenPos));
        _rot = axis2 * beta2;

        _v1 = (choosenPos - _ray2.origin);
        _v2 = rotatePointAroundPoint(choosenPos, _BlackHoles[choosenBH].position, axis2, beta2) - choosenPos;
        _v3 = normalize(rodrigez(choosenDir, axis2, beta));
    }
    return iscross;
}
bool solveCrossVector2(Ray ray, float3 rot, float3 v1, float3 v2, float3 v3, float3 center, int forbidden[100], int forbiddenC, out Ray _ray2, out float3 _rot, out float3 _v1, out float3 _v2, out float3 _v3, out int choosenBH)
{
    float3 axis = normalize(rot);
    float beta = length(rot);
    float3 startDir = ray.direction;
    float3 endDir = normalize(v3);
    float3 startPos = ray.origin + v1;
    float3 endPos = ray.origin + v1 + v2;
    float3 diff = endPos - startPos;

    _v1 = float3(0, 0, 0);
    _v2 = float3(0, 0, 0);
    _v3 = float3(0, 0, 0);
    _rot = float3(0, 0, 0);
    _ray2 = CreateRay(float3(0, 0, 0), float3(0, 0, 0));

    bool iscross = false;
    float outDMin = 1000;
    float3 choosenDir = float3(0, 0, 0);
    float3 choosenPos = float3(0, 0, 0);
    choosenBH = -1;

    uint c, s;
    _BlackHoles.GetDimensions(c, s);

    for (int i = 0; i < (int) c; ++i)
    {
        if (contains(forbidden, forbiddenC, i))
            continue;
        
        float3 nextBlackHole = _BlackHoles[i].position;

        float3 projection = projectOnPlane(nextBlackHole, axis);

        float gamma = angleAdvanced(startPos - center, projection - center, axis);
        float outD = 0;
        if (gamma >= 0 && gamma <= beta)
        {
            //zawiera się
            outD = gamma / beta;

            iscross = true;
            if (outD <= outDMin)
            {
                outDMin = outD;
                choosenDir = normalize(rodrigez(startDir, axis, beta * outD));
                choosenPos = startPos + diff * outD;
                choosenBH = i;
            }
        }
        else
        {
            //nie zawiera sie
        }
    }
    if (iscross)
    {
        //ustaw wyjscie
        _ray2 = CreateRay(choosenPos - choosenDir * (length(v1) + length(diff) * outDMin), choosenDir);
        float beta2 = getBlackHoleAngle(_BlackHoles[choosenBH], _ray2);
        float3 axis2 = normalize(crossUnity(choosenDir, _BlackHoles[choosenBH].position - choosenPos));
        _rot = axis2 * beta2;

        _v1 = (choosenPos - _ray2.origin);
        _v2 = rotatePointAroundPoint(choosenPos, _BlackHoles[choosenBH].position, axis2, beta2) - choosenPos;
        _v3 = normalize(rodrigez(choosenDir, axis2, beta));
    }
    return iscross;
}
/*bool solvecrossUnityVector(Ray ray, float3 rot, float3 v1, float3 v2, float3 v3, int forbidden[100], int forbiddenC, out Ray _ray2, out float3 _rot, out float3 _v1, out float3 _v2, out float3 _v3, out int choosenBH)
{
    float3 axis = normalize(rot);
    float beta = length(rot);
    float3 startDir = ray.direction;
    float3 endDir = normalize(v3);
    float3 startPos = ray.origin + v1;
    float3 endPos = ray.origin + v1 + v2;
    float3 diff = endPos - startPos;

    _v1 = float3(0, 0, 0);
    _v2 = float3(0, 0, 0);
    _v3 = float3(0, 0, 0);
    _rot = float3(0, 0, 0);
    _ray2 = CreateRay(float3(0, 0, 0), float3(0, 0, 0));

    bool iscrossUnity = false;
    float outDMin = 1000;
    float3 choosenDir = float3(0, 0, 0);
    float3 choosenPos = float3(0, 0, 0);
    choosenBH = -1;

    uint c, s;
    _BlackHoles.GetDimensions(c, s);

    for (uint i = 0; i < c; ++i)
    {
        if (contains(forbidden, forbiddenC, i))
            continue;
        float3 nextBlackHole = _BlackHoles[i].position;

        float3 pos, dir;
        float outD;
            
            //metodaNewtona
        float epsilon = 0.001f;
        float x = 0.5f;
        float delta = 0;
        pos = float3(0, 0, 0);
        dir = float3(0, 0, 0);
        outD = 0;
        for (uint j = 0; j < 10; ++j)
        {
            float3 d = rodrigez(startDir, axis, beta * x);
            float3 pointt = startPos + normalize(diff) * length(diff) * x;
            float3 tmp = pointt - nextBlackHole;
            float ang = angle(d, normalize(tmp));
            float _f = abs(cos(ang) * length(tmp));

            float dx = 0.001f;

            float3 d2 = rodrigez(startDir, axis, beta * (x + dx));
            float3 point2 = startPos + normalize(diff) * length(diff) * (x + dx);
            float3 tmp2 = point2 - nextBlackHole;
            float ang2 = angle(d2, normalize(tmp2));
            float _f2 = abs(cos(ang2) * length(tmp2));

            float _fPrim = (_f2 - _f) / dx;
            float tmp3 = x - _f / _fPrim;
            delta = abs(tmp3 - x);
            x = tmp3;
            if (delta < epsilon)
            {
                break;
            }
        }
        if (delta < epsilon && x >= 0 && x <= 1)
        {
                //sukces
            outD = x;

                //pos = startPos + diff.normalized * diff.magnitude * x;
                //dir = getInterpolationDirection(startDir, axis, beta, x).normalized;
                
                //isSuccess = true;

            iscrossUnity = true;
            if (outD <= outDMin)
            {
                outDMin = outD;
                choosenDir = normalize(rodrigez(startDir, axis, beta * x));
                choosenPos = startPos + normalize(diff) * length(diff) * outD;
                choosenBH = i;
            }
        }
    }
    if (iscrossUnity)
    {
            //ustaw wyjscie
        _ray2 = CreateRay(choosenPos - choosenDir * (length(v1) + length(diff) * outDMin), choosenDir);
        float beta2 = getBlackHoleAngle(_BlackHoles[choosenBH], _ray2);
        float3 axis2 = normalize(crossUnity(choosenDir, _BlackHoles[choosenBH].position - choosenPos));
        _rot = axis2 * beta2;

        _v1 = (choosenPos - _ray2.origin);
        _v2 = rotatePointAroundPoint(choosenPos, _BlackHoles[choosenBH].position, axis2, beta2) - choosenPos;
        _v3 = normalize(rodrigez(choosenDir, axis2, beta));
    }
    return iscrossUnity;
}*/
static int hitsDebug = 0;
bool nextPosition(Ray ray, float rayLength, int forbiddenIn[100], int forbiddenC, out float3 v1, out float3 v2, out float3 v3, out int outForbidden[100], out int outForbiddenC, out bool shadowHit)
{
    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = float3(0, 0, 0);

    int forbidden[100];
    for (int t = 0; t < forbiddenC; ++t)
    {
        forbidden[t] = forbiddenIn[t];
    }

        int frontId = -1;
    float minDist = 99999999;

    float3 totalRotVector = float3(0, 0, 0);
    float3 halfRotVector = float3(0, 0, 0);

    shadowHit = false;

    outForbiddenC = 0;

    uint c, s;
    _BlackHoles.GetDimensions(c, s);

    bool istnieje = false;
    for (int i = 0; i < c; ++i)
    {
        if (contains(forbidden, forbiddenC, i))
            continue;
        BlackHole center = _BlackHoles[i];
        float3 axis = normalize(getAxis(ray, center.position));
        float d = getApproachCollisionDistance(ray, center.position);
        if (d > 0)
        {
            if (d < minDist)
            {
                minDist = d;
                frontId = i;
            }
        }
    }

    float3 v2out = float3(0, 0, 0);
    float3 v3out = ray.direction;

    if (frontId >= 0)
    {
        istnieje = true;
        forbidden[forbiddenC] = frontId;
        hitsDebug++;
        forbiddenC++;
        outForbidden[outForbiddenC] = frontId;
        outForbiddenC++;

        v1 = ray.direction * minDist;
        float3 rot;
        float3 mv1;
        float3 mv2;
        float3 mv3;
        Ray extendedRay = CreateRay(ray.origin - ray.direction * rayLength, ray.direction);
        solveFullState(extendedRay, frontId, rot, mv1, mv2, mv3);
        if (length(rot) >= 90)
        {
            //bh shadow
            v2 = _BlackHoles[frontId].position - (ray.origin + v1);
            shadowHit = true;
            return false;
        }
        v2out += mv2;
        halfRotVector += rot / 2.0f;
        for (int _i = 0; _i < 10; ++_i)
        {
            Ray ray2;
            float3 ov1, ov2, ov3, orot;
            int bhInd;
            bool state = solveCrossVector2(extendedRay, rot, mv1, mv2, mv3, _BlackHoles[frontId].position, forbidden, forbiddenC, ray2, orot, ov1, ov2, ov3, bhInd);
            //bool state = solvecrossUnityVector(ray, rot, v1, mv2, mv3, forbidden, forbiddenC, ray2, orot, ov1, ov2, ov3, bhInd);

            if (state)
            {
                if (length(orot) >= 90)
                {
                    //bh shadow
                    v2 = _BlackHoles[bhInd].position - (ray.origin + v1);
                    shadowHit = true;
                    return false;
                }
                v2out += ov2;
                halfRotVector += orot / 2.0f;
                //forbidden.Add(bhInd);
                //outForbidden.Add(frontId);
                forbidden[forbiddenC] = bhInd;
                forbiddenC++;
                outForbidden[outForbiddenC] = bhInd; //to bylo inaczej !!!
                outForbiddenC++;
                hitsDebug++;
            }
            else
                break;
        }
    }
    else
    {
            //koniec, promień leci w nieskończoność
    }
    v2 = v2out;
    v3 = rodrigez(v3out, normalize(halfRotVector), length(halfRotVector) * 2);
    return istnieje;
}
void startPosition(Ray ray, out float3 v1, out float3 v2, out float3 v3, out int forbidden[100], out int forbiddenC, out bool shadowHit)
{
    
    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = float3(0, 0, 0);

    forbiddenC = 0;

    int front = -1;
    float minDist = 99999999;
    shadowHit = false;
    float3 totalRotVector = float3(0, 0, 0);
    float3 halfRotVector = float3(0, 0, 0);

    /*forbiddenC = 2;
    forbidden[0] = 0;
    forbidden[1] = 1;*/


    uint c, s;
    _BlackHoles.GetDimensions(c,s);

    for (uint i = 0; i < c; ++i)
    {
        if (contains(forbidden, forbiddenC, i))
            continue;
        BlackHole center = _BlackHoles[i];
        float3 axis = (getAxis(ray, center.position));
        float d = getApproachCollisionDistance(ray, center.position);
        if (d <= 0)
        {
                //za lub posrednio
            float beta = getBlackHoleAngle(center, ray);
            if (beta >= 90)
            {
                //bh shadow
                v2 = center.position - ray.origin;
                shadowHit = true;
                return;
            }
            beta = beta % (2 * PI);
            float3 vecBack = (ray.origin + ray.direction * d) - center.position;
            float3 dir = ray.origin - center.position;
            if (angleAdvanced(vecBack, dir, axis) > beta)
            {
                //za
                totalRotVector += axis * beta;
                halfRotVector += axis * beta / 2.0f;
                forbidden[forbiddenC] = i;
                forbiddenC++;
            }
        }
    }
    float3 v2out = float3(0, 0, 0);
    ray.direction = rodrigez(ray.direction, normalize(halfRotVector), length(halfRotVector) * 2);
    halfRotVector = float3(0, 0, 0);
    float3 v3out = ray.direction;
    for (uint i2 = 0; i2 < c; ++i2)
    {
        if (contains(forbidden, forbiddenC, i2))
            continue;
        BlackHole center = _BlackHoles[i2];
        float3 axis = normalize(getAxis(ray, center.position));
        float d = getApproachCollisionDistance(ray, center.position);
        if (d > 0)
        {

        }
        else
        {
            float beta = getBlackHoleAngle(center, ray);
            float3 vecBack = (ray.origin + ray.direction * d) - center.position;
            float3 dir = ray.origin - center.position;
            if (angleAdvanced(vecBack, dir, axis) <= beta)
            {
                forbidden[forbiddenC] = i2;
                forbiddenC++;
                    //stan posredni
                float3 rot;
                float3 mv1;
                float3 mv2;
                float3 mv3;
                solveMiddleState(ray, i2, rot, mv1, mv2, mv3);
                v2out += mv2;
                halfRotVector += rot / 2.0f;

                if (beta >= 90)
                {
                        //bh shadow
                    v1 = ray.direction * d;
                    v2 = center.position - ray.origin - v1;
                    shadowHit = true;
                    return;
                }

                for (uint _i = 0; _i < 10; ++_i)
                {
                    Ray ray2;
                    float3 ov1, ov2, ov3, orot;
                    int bhInd;
                    bool state = solveCrossVector2(ray, rot, mv1, mv2, mv3, _BlackHoles[i2].position, forbidden, forbiddenC, ray2, orot, ov1, ov2, ov3, bhInd);
                        
                    if (state)
                    {
                        if (length(orot) >= 90)
                        {
                            //bh shadow
                            v1 = ray.direction * d;
                            v2 = _BlackHoles[bhInd].position - ray.origin - v1;
                            shadowHit = true;
                            return;
                        }
                        v2out += ov2;
                        halfRotVector += orot / 2.0f;
                        forbidden[forbiddenC] = bhInd;
                        forbiddenC++;
                    }
                    else
                        break;
                }
            }
            else
            {
                halfRotVector += axis * beta / 2.0f;
                forbidden[forbiddenC] = i2;
                forbiddenC++;
            }
        }
    }
    v2 = v2out;
    v3 = rodrigez(v3out, normalize(halfRotVector), length(halfRotVector) * 2);
}

void tester(int forbiddenX[100], int forbiddenXC, out int forbidden[100], out int forbiddenC)
{
    forbiddenC = forbiddenXC;
    forbidden[0] = forbiddenX[0];
}

bool calcRay2(Ray _ray)
{
    return true;
    clearPoints();
    addPoint(_ray.origin);



    float3 v1, v2, v3;
    int forbidden[100];
    int forbiddenC = 0;

    /*forbidden[0] = 0;
    //forbiddenC++;
    forbidden[1] = 1;
    //forbiddenC++;*/


    /*if (contains(forbidden, forbiddenC, 123))
    {
        //shadowHit = true;
        return true;
    }*/

    bool shadowHit = false;
    
    //startPosition(_ray, v1, v2, v3, forbidden, forbiddenC, shadowHit);
    //v1 = float3(0,0,0);//debug
    //v2 = float3(0, 0, 0);
    //v3 = _ray.direction;
    //

    addPoint(_ray.origin + v1);
    addPoint(_ray.origin + v1 + v2);
    if (shadowHit)
    {
        return true;
    }
    float _length = 0;
    //addPoint(_ray.origin + v1 + v2 + v3 * 1000);
    //addPoint(v3);
    for (int i = 0; i < 10; ++i)
    {
        _length += (length(v1) + length(v2));
        _ray.direction = v3;
        _ray.origin = _ray.origin + v1 + v2;
        int forbidden2[100];
        int forbidden2C;
        bool state = nextPosition(_ray, _length, forbidden, forbiddenC, v1, v2, v3, forbidden2, forbidden2C, shadowHit);
        if (shadowHit)
        {
            addPoint(_ray.origin + v1);
            addPoint(_ray.origin + v1 + v2);
            break;
        }
        if (!state)
        {
            addPoint(_ray.origin + v1 + v2 + v3 * 1000);
            break;
        }
        forbidden = forbidden2;
        forbiddenC = forbidden2C;

        /*if (forbidden[0] == 1 || forbidden[1] == 1 || forbidden[2] == 1)
            return true;*/

        /*for (int k = 0; k < forbidden2C; ++k)
        {
            forbidden[forbiddenC] = forbidden2[k];
            forbiddenC++;
        }*/

        addPoint(_ray.origin + v1);
        addPoint(_ray.origin + v1 + v2);
    }
    addPoint(v3); //debug
    return shadowHit;
}
float angleToPlane(float3 dir, float3 normal)
{
    float3 pr = projectOnPlane(dir, normal);
    float ang = angle(pr, dir) * 180 / PI;
    if (angle(pr, normal) > 90)
        ang *= -1;
    return ang;
}
bool calcRay3(Ray _ray)
{
    clearPoints();
    addPoint(_ray.origin);

    float3 v1, v2, v3;
    int forbidden[100];
    int forbiddenC = 0;
    bool shadowHit = false;
    startPosition(_ray, v1, v2, v3, forbidden, forbiddenC, shadowHit);
    //v1 = float3(0, 0, 0); //debug
    //v2 = float3(0, 0, 0);
    //v3 = _ray.direction;

    addPoint(_ray.origin + v1);
    addPoint(_ray.origin + v1 + v2);
    if (shadowHit)
    {
        return shadowHit;
    }
    float raylength = 0;
    for (int i = 0; i < 5; ++i)
    {
        raylength += length(v1) + length(v2);
        _ray.direction = v3;
        _ray.origin = _ray.origin + v1 + v2;
        int forbidden2[100];
        int forbidden2C = 0;
        bool state = nextPosition(_ray, raylength, forbidden, forbiddenC, v1, v2, v3, forbidden2, forbidden2C, shadowHit);
        if (shadowHit)
        {
            addPoint(_ray.origin + v1);
            addPoint(_ray.origin + v1 + v2);
            break;
        }
        if (!state)
        {
            addPoint(_ray.origin + v1 + v2 + v3 * 100);
            break;
        }
            //forbidden.AddRange(forbidden2);
        //forbidden = forbidden2;
        //forbiddenC = forbidden2C;

        for (int k = 0; k < forbidden2C; ++k)
        {
            forbidden[forbiddenC] = forbidden2[k];
            forbiddenC++;
        }

        addPoint(_ray.origin + v1);
        addPoint(_ray.origin + v1 + v2);
    }
    //Debug.Log(angleToPlane(v3, Vector3.up));
    addPoint(v3); //debug
    /*if (angleToPlane(v3, float3(0, 1, 0)) < 2.0f)
    {
        return true;
    }*/
    return shadowHit;
}

////////////////////

void solveFullState2(Ray ray, int bhInd, float addLength, out float3 rot, out float3 v1, out float3 v2, out float3 v3, out float angle, out float3 axis)
{
    rot = float3(0, 0, 0);
    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = float3(0, 0, 0);
    
    angle = getBlackHoleAngle(_BlackHoles[bhInd], ray, addLength);
    axis = normalize(getAxis(ray, _BlackHoles[bhInd].position));
    float d = getApproachCollisionDistance(ray, _BlackHoles[bhInd].position);
    v1 = d * ray.direction;
    float3 hitBack = v1 + ray.origin;
    float3 hitFront = rotatePointAroundPoint(hitBack, _BlackHoles[bhInd].position, axis, angle);
    v2 = hitFront - hitBack;
    v3 = normalize(rodrigez(ray.direction, axis, angle));
    rot = axis * angle;
}

float SolveCrossVectorFastOld(float3 P0, float3 dir0, float3 P1, float3 dir1, float beta, float3 axis, float3 nextBlackHole)
{
    float x = 0.5f;
    float3 v2 = P1 - P0;
    float delta = 0;
    float epsilon = 0.001f;
    
    float3 nextBlackHoleProjection = projectOnPlane(nextBlackHole, axis);
    for (int i = 0; i < 10; ++i)
    {
        float3 d1 = rodrigez(dir0, -axis, beta * x);
        float3 point1 = P0 + v2 * x;
        float3 tmp1 = nextBlackHoleProjection - point1;
            //float _f = float3.Dot(normalize(tmp1), d1);  //ma zbiegac do zera
        float _f = angle(tmp1, d1) - PI / 2.0f;
        float dx = 0.001f;

        float3 d2 = rodrigez(dir0, -axis, beta * (x + dx));
        float3 point2 = P0 + v2 * (x + dx);
        float3 tmp2 = nextBlackHoleProjection - point2;
            //float _f2 = float3.Dot(normalize(tmp2), d2);  //ma zbiegac do zera
        float _f2 = angle(tmp2, d2) - PI / 2.0f;

        float _fPrim = (_f2 - _f) / dx;
        float tmp3 = x - _f / _fPrim;
        delta = abs(tmp3 - x);
        x = tmp3;
            //Debug.Log("X: "+x+"\t delta:" + delta + "\tx: "+x);
        if (delta < epsilon)
        {
            break;
        }
    }
    return x;
}

float SolveCrossVectorFast(float3 P0, float3 dir0, float3 P1, float3 dir1, float beta, float3 axis, float3 nextBlackHole)
{
    float x = 0;
    float3 v2 = P1 - P0;
    float delta = 0;
    float epsilon = 0.001f;
    float dx = 0.001f;
    //axis = -axis;
        //Debug.Log("start");
    float3 nextBlackHoleProjection = projectOnPlane(nextBlackHole, axis);
    for (int i = 0; i < 10; ++i)
    {
        float3 d1 = rodrigez(dir0, axis, beta * x);
        float3 point1 = P0 + v2 * x;
        float3 tmp1 = nextBlackHoleProjection - point1;
        float _f = dot(normalize(tmp1), d1); //ma zbiegac do zera
            //float _f = angle(tmp1, d1) - PI / 2.0f;

        float3 d2 = rodrigez(dir0, axis, beta * (x + dx));
        float3 point2 = P0 + v2 * (x + dx);
        float3 tmp2 = nextBlackHoleProjection - point2;
        float _f2 = dot(normalize(tmp2), d2); //ma zbiegac do zera
            //float _f2 = angle(tmp2, d2) - PI / 2.0f;

        float _fPrim = (_f2 - _f) / dx;
        if (abs(_fPrim) < 0.1f)
            _fPrim = -0.1f;
        float diff = _f / _fPrim;
        diff = clamp(diff, -0.4f, 0.4f);
        float tmp3 = (x - diff);

        delta = abs(tmp3 - x);
        x = tmp3;
            //Debug.Log("X: "+x+"\t delta:" + delta + "\tx: "+x);
        if (delta < epsilon)
        {
            break;
        }
    }
    float x0 = x;
    x = 1;
    for (int i = 0; i < 10; ++i)
    {
        float3 d1 = rodrigez(dir0, axis, beta * x);
        float3 point1 = P0 + v2 * x;
        float3 tmp1 = nextBlackHoleProjection - point1;
        float _f = dot(normalize(tmp1), d1); //ma zbiegac do zera
            //float _f = angle(tmp1, d1) - PI / 2.0f;

        float3 d2 = rodrigez(dir0, axis, beta * (x + dx));
        float3 point2 = P0 + v2 * (x + dx);
        float3 tmp2 = nextBlackHoleProjection - point2;
        float _f2 = dot(normalize(tmp2), d2); //ma zbiegac do zera
            //float _f2 = angle(tmp2, d2) - PI / 2.0f;

        float _fPrim = (_f2 - _f) / dx;
        if (abs(_fPrim) < 0.1f)
            _fPrim = 0.1f;
        float diff = _f / _fPrim;
        diff = clamp(diff, -0.4f, 0.4f);
        float tmp3 = (x - diff);

        delta = abs(tmp3 - x);
        x = tmp3;
            //Debug.Log("X: "+x+"\t delta:" + delta + "\tx: "+x);
        if (delta < epsilon)
        {
            break;
        }
    }
    float x1 = x;

    if (x0 == x1)
        return x0;
    if (x0 >= 0 && x0 <= 1)
        return x0;
    if (x1 >= 0 && x1 <= 1)
        return x1;


        //Debug.Log("stop");
        /*if (x >= 0 && x <= 1)
        {
            Debug.Log("TAK");
        } else
        {
            Debug.Log("NIE");
        }*/
    return x;
}

bool crossConditionAdvanced(float3 startPos, float3 startDir, float3 endPos, float3 endDir, float3 axis, int bhId)
{
    float3 nextBlackHole = _BlackHoles[bhId].position;
    float3 tmp1 = startPos - nextBlackHole;
    float l1 = length(tmp1) * dot(normalize(-startDir), normalize(tmp1));
    float3 tmp2 = endPos - nextBlackHole;
    float l2 = length(tmp2) * dot(normalize(-endDir), normalize(tmp2));

    float epsilon = 0.001f;

    if (l1 >= -epsilon && l2 <= epsilon)
    {
            //zawiera się
        return true;
    }
    else
    {
            //nie zawiera sie
        return false;
    }
}

static bool forbiddenStat[100];
/*bool bendVector(Ray ray, float rayLength, bool backMode, out float3 v1, out float3 v2, out float3 v3, out bool shadowHit)
{
    uint numObj, stride;
    _BlackHoles.GetDimensions(numObj, stride);
    bool forbiddenStat2[100];
    for (int i = 0; i < numObj; ++i)
        forbiddenStat2[i] = false;

    v1 = float3(0, 0, 0);
    v2 = float3(0, 0, 0);
    v3 = ray.direction;
    shadowHit = false;
    float3 rot = float3(0,0,0); //caly obrot
    if (backMode)
    {
        for (int i = 0; i < numObj; ++i)
        {
            BlackHole center = _BlackHoles[i];
            float3 axis = getAxis(ray, center.position);

                //nastepna czarna dziura
            float3 tmp_v2 = float3(0,0,0);
            float d = getApproachCollisionDistance(ray, center.position);
            if (d < 0)
            {
                forbiddenStat[i] = true;
                forbiddenStat2[i] = true;
                float beta = getBlackHoleAngle(center, ray);
                rot += axis * beta;

                if (length(rot) >= 90)
                {
                        //bh shadow
                    v2 = float3(0, 0, 0);
                    v3 = _BlackHoles[i].position - (ray.origin);
                    shadowHit = true;
                    return false;
                }

                v3 = rodrigez(ray.direction, rot, length(rot));

                float3 vecBack = (ray.origin + ray.direction * d) - center.position;
                float3 dir = ray.origin - center.position;
                if (angleAdvanced(vecBack, dir, axis) <= beta)
                {
                        //middle state
                    float3 rod1 = rodrigez(ray.direction, axis, beta / 2.0f);
                    float3 hitBack = planeIntersection(center.position, ray.direction, ray.origin, rod1);
                    float3 hitFront = rotatePointAroundPoint(hitBack, center.position, axis, beta);
                    tmp_v2 = hitFront - ray.origin;
                }
                else
                {
                        //back state
                }
                v2 += tmp_v2;
            }

                //szukanie stanow posrednich dla V2
            for (int j = 0; j < numObj; ++j)
            {
                if (i == j || forbiddenStat[j])
                    continue;
                bool cond = crossConditionAdvanced(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, normalize(rot), j);

                if (cond)
                {
                    float x = SolveCrossVectorFast(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, length(rot), normalize(rot), _BlackHoles[j].position);
                    if (x >= 0 && x <= 1)
                    {
                            //modyfikacja v2
                        //Debug.Log("zaawansowane wyznaczenie sciezki aktywne");
                        forbiddenStat[j] = true;
                        forbiddenStat2[j] = true;
                        float3 hitpoint = ray.origin + v1 + v2 * x;

                        float3 dir = rodrigez(ray.direction, axis, length(rot) * x);
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(hitpoint, dir), j, length(hitpoint - ray.origin), _rot, _v1,  _v2,  _v3, _angle,_axis);

                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = hitpoint - (ray.origin + v1);
                            v3 = _BlackHoles[j].position - hitpoint;
                            shadowHit = true;
                            return false;
                        }

                        rot += _rot;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        v2 += _v2;
                    }
                }
            }
        }
    }
    else
    {
            //normalny tryb
        float nearestDist = 9999999;
        int bhid = -1;
        for (int i = 0; i < numObj; ++i)
        {
            if (forbiddenStat[i])
                continue;
            BlackHole center = _BlackHoles[i];
            float d = getApproachCollisionDistance(ray, center.position);
            if (d >= 0 && d < nearestDist)
            {
                nearestDist = d;
                bhid = i;
            }
        }

        if (bhid == -1)
        {
                //STOP promien leci w nieskonczonosc
            return false;
        }
        else
        {
                {
                float3 _v1, _v2, _v3, _rot, _axis;
                float _angle;
                solveFullState2(ray, bhid, rayLength, _rot, _v1,_v2,_v3, _angle,_axis);
                rot += _rot;
                v3 = rodrigez(ray.direction, rot, length(rot));
                v2 += _v2;
                v1 = _v1;
                forbiddenStat[bhid] = true;
                    //forbiddenStat2[bhid] = true;//delay
                if (length(_rot) >= 90)
                {
                        //bh shadow
                    v2 = float3(0,0,0);
                    v3 = _BlackHoles[bhid].position - (ray.origin + v1);
                    shadowHit = true;
                    return false;
                }
            }

            float3 axis = getAxis(ray, _BlackHoles[bhid].position);
                //szukanie stanow posrednich dla V2
            bool ifany = false;
            for (int j = 0; j < numObj && bhid != -1; ++j)
            {
                if (bhid == j || forbiddenStat[j])
                    continue;
                bool cond = crossConditionAdvanced(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, normalize(rot), j);
                //cond = false;
                if (cond)
                {
                    ifany = true;
                    float x = SolveCrossVectorFast(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, length(rot), normalize(rot), _BlackHoles[j].position);
                    if (x >= 0 && x <= 1)
                    {
                            //modyfikacja v2
                            //Debug.Log("zaawansowane wyznaczenie sciezki aktywne");
                        forbiddenStat[j] = true;
                        forbiddenStat2[j] = true;
                        float3 hitpoint = ray.origin + v1 + v2 * x;

                        float3 dir = rodrigez(ray.direction, normalize(rot), length(rot) * x);
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(hitpoint, dir), j, rayLength + length(hitpoint - ray.origin),_rot, _v1, _v2,_v3, _angle, _axis);

                        rot += _rot;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        v2 += _v2;

                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = hitpoint - (ray.origin + v1);
                            v3 = _BlackHoles[j].position - hitpoint;
                            shadowHit = true;
                            return false;
                        }

                        j = -1;
                    }
                }
            }
            if (!ifany)
                forbiddenStat2[bhid] = true;

            for (int k = 0; k < numObj; ++k)
                forbiddenStat[k] = forbiddenStat2[k];

                //rzutowanie rownolegle frontowe
                {
                float3 frontHit = ray.origin + v1;
                for (int i = 0; i < numObj; ++i)
                {
                    if (forbiddenStat[i] || i == bhid)
                        continue;

                    float3 backHit = frontHit + v2;
                    float fullLength = dot(ray.direction, backHit - frontHit);

                    if (length(_BlackHoles[i].position - frontHit) < length(_BlackHoles[bhid].position - frontHit))
                        continue;
                    float testLength = dot(ray.direction, _BlackHoles[i].position - frontHit);
                    float ratio = testLength / fullLength;
                        //Debug.Log("ratio: "+ ratio);
                    if (ratio >= 0 && ratio <= 1)
                    {
                        ratio = 1 - ratio;
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(ray, i, rayLength, _rot, _v1, _v2, _v3, _angle, _axis);
                        v2 += _v2 * ratio;
                        rot += _rot * ratio;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = float3(0,0,0);
                            v3 = _BlackHoles[i].position - (ray.origin + v1);
                            shadowHit = true;
                            return false;
                        }
                    }
                }
            }

                //rzutowanie rownolegle wsteczne
                {
                float3 frontHit = ray.origin + v1;
                for (int i = 0; i < numObj; ++i)
                {
                    if (forbiddenStat[i] || i == bhid)
                        continue;
                        
                    float3 backHit = frontHit + v2;
                    float fullLength = -dot(v3, backHit - frontHit);

                    if (length(_BlackHoles[i].position - backHit) < length(_BlackHoles[bhid].position - backHit))
                        continue;
                    float testLength = dot(v3, _BlackHoles[i].position - backHit);
                    float ratio = testLength / fullLength;
                        //Debug.Log("ratio: "+ ratio);
                    if (ratio >= 0 && ratio <= 1)
                    {
                        ratio = 1 - ratio;
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(ray.origin + v1 + v2, v3), i, rayLength + length(v1) + length(v2),_rot, _v1, _v2, _v3, _angle, _axis);
                        v2 += _v2 * ratio;
                        rot += _rot * ratio;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = float3(0,0,0);
                            v3 = _BlackHoles[i].position - (ray.origin + v1);
                            shadowHit = true;
                            return false;
                        }
                    }
                }
            }
        }
    }
    for (int k = 0; k < numObj; ++k)
        forbiddenStat[k] = forbiddenStat2[k];
    return true;
}*/

static bool debug_locker = false;

bool bendVector(Ray ray, float rayLength, bool backMode, out float3 v1, out float3 v2, out float3 v3, out bool shadowHit)
{
    uint numObj, stride;
    _BlackHoles.GetDimensions(numObj, stride);
    bool forbiddenStat2[100];
    for (int i = 0; i < numObj; ++i)
        forbiddenStat2[i] = false;

    v1 = float3(0,0,0);
    v2 = float3(0,0,0);
    v3 = ray.direction;
    shadowHit = false;
    float3 rot = float3(0,0,0); //caly obrot
    if (backMode)
    {
        for (int i = 0; i < numObj; ++i)
        {
            BlackHole center = _BlackHoles[i];
            float3 axis = getAxis(ray, center.position);

                //nastepna czarna dziura
            float3 tmp_v2 = float3(0,0,0);
            float d = getApproachCollisionDistance(ray, center.position);
            if (d < 0)
            {
                forbiddenStat[i] = true;
                forbiddenStat2[i] = true;
                float beta = getBlackHoleAngle(center, ray);
                rot += axis * beta;

                if (length(rot) >= 90)
                {
                        //bh shadow
                    v2 = float3(0,0,0);
                    v3 = _BlackHoles[i].position - (ray.origin);
                    shadowHit = true;
                    return false;
                }

                v3 = rodrigez(ray.direction, rot, length(rot));

                float3 vecBack = (ray.origin + ray.direction * d) - center.position;
                float3 dir = ray.origin - center.position;
                if (angleAdvanced(vecBack, dir, axis) <= beta)
                {
                        //middle state
                    float3 rod1 = rodrigez(ray.direction, axis, beta / 2.0f);
                    float3 hitBack = planeIntersection(center.position, ray.direction, ray.origin, rod1);
                    float3 hitFront = rotatePointAroundPoint(hitBack, center.position, axis, beta);
                    tmp_v2 = hitFront - ray.origin;
                }
                else
                {
                        //back state
                }
                v2 += tmp_v2;
            }

                //szukanie stanow posrednich dla V2
            for (int j = 0; j < numObj; ++j)
            {
                if (i == j || forbiddenStat[j])
                    continue;
                bool cond = crossConditionAdvanced(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, axis, j);

                if (cond)
                {
                    float x = SolveCrossVectorFast(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, length(rot), axis, _BlackHoles[j].position);
                    if (x >= 0 && x <= 1)
                    {
                            //modyfikacja v2
                            //Debug.Log("zaawansowane wyznaczenie sciezki aktywne");
                        forbiddenStat[j] = true;
                        forbiddenStat2[j] = true;
                        float3 hitpoint = ray.origin + v1 + v2 * x;
                        

                        float3 dir = rodrigez(ray.direction, axis, length(rot) * x);
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(hitpoint, dir), j, length(hitpoint - ray.origin), 
                        _rot, 
                        _v1, 
                        _v2, 
                        _v3, 
                        _angle, 
                        _axis);

                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = hitpoint - (ray.origin + v1);
                            v3 = _BlackHoles[j].position - hitpoint;
                            shadowHit = true;
                            return false;
                        }

                        rot += _rot;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        v2 += _v2;
                    }
                }
            }
        }
    }
    else
    {
            //normalny tryb
        float nearestDist = 9999999;
        int bhid = -1;
        for (int i = 0; i < numObj; ++i)
        {
            if (forbiddenStat[i])
                continue;
            BlackHole center = _BlackHoles[i];
            float d = getApproachCollisionDistance(ray, center.position);
            if (d >= 0 && d < nearestDist)
            {
                nearestDist = d;
                bhid = i;
            }
        }

        if (bhid == -1)
        {
                //STOP promien leci w nieskonczonosc
            return false;
        }
        else
        {
                {
                float3 _v1, _v2, _v3, _rot, _axis;
                float _angle;
                solveFullState2(ray, bhid, rayLength, 
                _rot, 
                _v1, 
                _v2, 
                _v3, 
                _angle, 
                _axis);
                rot += _rot;
                v3 = rodrigez(ray.direction, rot, length(rot));
                v2 += _v2;
                v1 = _v1;
                forbiddenStat[bhid] = true;
                    //forbiddenStat2[bhid] = true;//delay
                if (length(_rot) >= 90)
                {
                        //bh shadow
                    v2 = float3(0,0,0);
                    v3 = _BlackHoles[bhid].position - (ray.origin + v1);
                    shadowHit = true;
                    return false;
                }
            }

            float3 axis = getAxis(ray, _BlackHoles[bhid].position);
                //szukanie stanow posrednich dla V2
            bool ifany = false;
            for (int j = 0; j < numObj && bhid != -1; ++j)
            {
                if (bhid == j || forbiddenStat[j])
                    continue;
                bool cond = crossConditionAdvanced(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, normalize(rot), j);
                //cond = false;
                if (cond)
                {
                    ifany = true;
                    float x = SolveCrossVectorFast(ray.origin + v1, ray.direction, ray.origin + v1 + v2, v3, length(rot), normalize(rot), _BlackHoles[j].position);
                    if (x >= 0 && x <= 1)
                    {
                            //modyfikacja v2
                            //Debug.Log("zaawansowane wyznaczenie sciezki aktywne");
                        forbiddenStat[j] = true;
                        forbiddenStat2[j] = true;
                        float3 hitpoint = ray.origin + v1 + v2 * x;
                        

                        float3 dir = rodrigez(ray.direction, normalize(rot), length(rot) * x);
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(hitpoint, dir), j, rayLength + length(hitpoint - ray.origin), _rot,  _v1, _v2, _v3,  _angle, _axis);

                        if (debug_locker)
                            DEBoutput[0] = float3(j, rayLength + length(hitpoint - ray.origin), _angle);

                        rot += _rot;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        v2 += _v2;

                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = hitpoint - (ray.origin + v1);
                            v3 = _BlackHoles[j].position - hitpoint;
                            shadowHit = true;
                            return false;
                        }

                        j = -1;
                    }
                }
            }
            if (!ifany)
                forbiddenStat2[bhid] = true;

            //for (int k = 0; k < numObj; ++k)
            //    forbiddenStat[k] = forbiddenStat2[k];

                //rzutowanie rownolegle frontowe
            if (false)
            {
                float3 frontHit = ray.origin + v1;
                for (int i = 0; i < numObj; ++i)
                {
                    if (forbiddenStat[i] || i == bhid)
                        continue;

                    float3 backHit = frontHit + v2;
                    float fullLength = dot(ray.direction, backHit - frontHit);

                    if (length(_BlackHoles[i].position - frontHit) < length(_BlackHoles[bhid].position - frontHit))
                        continue;
                    float testLength = dot(ray.direction, _BlackHoles[i].position - frontHit);
                    float ratio = testLength / fullLength;
                        //Debug.Log("ratio: "+ ratio);
                    if (ratio >= 0 && ratio <= 1)
                    {
                        ratio = 1 - ratio;
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(ray, i, rayLength, 
                        _rot, 
                        _v1, 
                        _v2, 
                        _v3, 
                        _angle, 
                        _axis);
                        v2 += _v2 * ratio;
                        rot += _rot * ratio;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = float3(0,0,0);
                            v3 = _BlackHoles[i].position - (ray.origin + v1);
                            shadowHit = true;
                            return false;
                        }
                    }
                }
            }

                //rzutowanie rownolegle wsteczne
            if (false)
            {
                float3 frontHit = ray.origin + v1;
                for (int i = 0; i < numObj; ++i)
                {
                    if (forbiddenStat[i] || i == bhid)
                        continue;
                        
                    float3 backHit = frontHit + v2;
                    float fullLength = -dot(v3, backHit - frontHit);

                    float3 tmpAx = normalize(rot);
                    float3 projbhid = projectOnPlane(_BlackHoles[bhid].position, tmpAx);
                    float3 proji = projectOnPlane(_BlackHoles[i].position, tmpAx);

                    if (length(proji - backHit) < length(projbhid - backHit))
                        continue;
                    float testLength = dot(v3, proji - backHit);
                    float ratio = testLength / fullLength;
                        //Debug.Log("ratio: "+ ratio);
                    if (ratio >= 0 && ratio <= 1)
                    {
                        ratio = 1 - ratio;
                        float3 _v1, _v2, _v3, _rot, _axis;
                        float _angle;
                        solveFullState2(CreateRay(ray.origin + v1 + v2, v3), i, rayLength + length(v1) + length(v2), _rot, _v1, _v2, _v3, _angle, _axis);
                        v2 += _v2 * ratio;
                        rot += _rot * ratio;
                        v3 = rodrigez(ray.direction, rot, length(rot));
                        if (length(_rot) >= 90)
                        {
                                //bh shadow
                            v2 = float3(0, 0, 0);
                            v3 = _BlackHoles[i].position - (ray.origin + v1);
                            shadowHit = true;
                            return false;
                        }
                    }
                }
            }
        }
    }
    //for (int k = 0; k < numObj; ++k)
    //    forbiddenStat[k] = forbiddenStat2[k];
    return true;
}

bool M4tester(Ray _ray)
{
    uint numObj, stride;
    _BlackHoles.GetDimensions(numObj, stride);

    for (int i = 0; i < numObj; ++i)
        forbiddenStat[i] = false;        

    clearPoints();

    float3 v1, v2, v3;
    bool shadowHit = false;

    int totalBends = 0;

    bendVector(_ray, 0, true, v1, v2, v3, shadowHit);
    totalBends++;

    addPoint(_ray.origin);
    addPoint(_ray.origin + v1);
    addPoint(_ray.origin + v1 + v2);
    float len = 0;

    if (shadowHit)
        return shadowHit;

    float3 lastv3 = v3;
    for (int i = 0; i < 5; ++i)
    {
        len += length(v1) + length(v2);
        _ray = CreateRay(_ray.origin + v1 + v2, v3);
        bool cond = bendVector(_ray, len, false, v1, v2, v3,shadowHit);
        totalBends++;
        if (shadowHit)
        {
            lastv3 = float3(0,0,0);
            addPoint(_ray.origin + v1);
            addPoint(_ray.origin + v1 + v2);
            lastv3 = float3(0,0,0);
            //addPoint(_ray.origin + v1 + v2 + v3);
            break;
        }
        if (cond == false)
            break;
        addPoint(_ray.origin + v1);
        //pointer.transform.position = _ray.origin + v1;
        addPoint(_ray.origin + v1 + v2);
        //pointer2.transform.position = _ray.origin + v1 + v2;
        lastv3 = v3;
    }

    //if (!shadowHit)
        //addPoint(_ray.origin + lastv3 * 100);

    addPoint(lastv3);

    return shadowHit;
}


float3 getBlackHoleAngleV(BlackHole bh, Ray ray)
{
    float a = getBlackHoleAngle(bh, ray);
    float3 axis = getAxis(ray, bh.position);

    return axis * a;
}
float3 getBlackHoleAngleVPrim(BlackHole bh, Ray ray, float step, out bool shadowHit)
{
    shadowHit = false;
        //ray = CreateRay(ray.origin, -ray.direction);
    float3 ret0 = getBlackHoleAngleV(bh, ray);
    float3 ret1 = getBlackHoleAngleV(bh, CreateRay(ray.origin + ray.direction * step, ray.direction));
    if (length(ret1) >= 90)
    {
        shadowHit = true;
    }
    return (ret0 - ret1);
}

/*float3 getBlackHoleAngleVPrim(BlackHole bh, Ray ray, float step, out bool shadowHit)
{
    shadowHit = false;
        //ray = CreateRay(ray.origin, -ray.direction);

    Ray tmp0 = ray;
    Ray tmp1 = CreateRay(ray.origin, -ray.direction);

    float3 a0 = getBlackHoleAngleV(bh, tmp0);
    float3 a1 = getBlackHoleAngleV(bh, tmp1);

    if (length(a1) > length(a0))
    {
        float3 ret0 = a0;
        float3 ret1 = getBlackHoleAngleV(bh, CreateRay(tmp0.origin + tmp0.direction * step, tmp0.direction));
        if (length(ret1) >= 90)
        {
            shadowHit = true;
        }
        return (ret0 - ret1);
    }
    else
    {
        float3 ret1 = a1;
        float3 ret0 = getBlackHoleAngleV(bh, CreateRay(tmp1.origin - tmp1.direction * step, tmp1.direction));
        if (length(ret1) >= 90)
        {
            shadowHit = true;
        }
        return (ret0 - ret1);
    }
}*/

bool calcRay5(Ray _ray)
{
    clearPoints();
    
    float step = 8;
    int steps = 25;

    uint n, stride;
    _BlackHoles.GetDimensions(n, stride);

    addPoint(_ray.origin);
    float3 prevVw = float3(0, 0, 0);
    for (int i = 0; i < steps; ++i)
    {
        float3 Vw = float3(0,0,0);
        for (int j = 0; j < n; ++j)
        {
            bool shadowHit;
            float3 prim = getBlackHoleAngleVPrim(_BlackHoles[j], _ray, step, shadowHit);
            Vw += prim;
            if (shadowHit)
            {
                float d = getApproachCollisionDistance(_ray, _BlackHoles[j].position);
                addPoint(_ray.origin + _ray.direction * d);
                addPoint(_BlackHoles[j].position);
                return true;
            }
        }
        if (i == 0)
            prevVw = Vw;
        float3 bend = (Vw + prevVw) / 2.0f * 0.45f;
        bend = Vw * 0.4f;

        float3 dir2 = rodrigez(_ray.direction, bend, length(bend));
        _ray = CreateRay(_ray.origin + dir2 * step, dir2);
        addPoint(_ray.origin);

        prevVw = Vw;
    }

    addPoint(_ray.direction);

    return false;
}


float getBlackHoleAngle2(BlackHole bc, Ray ray, float addLength = 0)//zrobic!!!! ignoruje promien
{
    float unit = bc.rs / 2.0f;

    float beta = 0;

    ray.origin = ray.origin - ray.direction * addLength;

    float3 vr = bc.position - ray.origin;
    float alpha = angle(ray.direction, vr);
    float r = length(vr) / unit;

    float _x_r = sqrt(sqrt(r)) / 4.0f;
    float _y_alpha = alpha / PI;

    float tableOutput = 0;
    tableOutput = getTable(_x_r, _y_alpha, 1);

    beta = tableOutput * PI / 180.0f; //w radianach

    return beta;
}

float3 getBlackHoleAngleV2(BlackHole bh, Ray ray, out bool shadowHit)
{
    shadowHit = false;
    float a = getBlackHoleAngle2(bh, ray);
    float3 axis = getAxis(ray, bh.position);
    if (a < 0)
        shadowHit = true;
    return axis * a;
}


float3 getBlackHoleAngleVPrim2(BlackHole bh, Ray ray, float step, out bool shadowHit, out float step2)
{
    uint n, stride;
    _BlackHoles.GetDimensions(n, stride);

    float3 p = ray.origin;
    float minDist = 99999999;
    float units = 0;
    for (int j = 0; j < n; ++j)
    {
        BlackHole center = _BlackHoles[j];

        float dist = length(center.position - p);
        dist = dist / center.rs / 2.0f;
        if (dist < minDist)
        {
            minDist = dist;
            units = length(center.position - p);
        }
    }

    step = (units / minDist);

    if (minDist < 3)
    {
            //step = units - (20 * units / minDist);
        step = (units / minDist) * 0.5f;
    }
    if (minDist > 20)
    {
            //step = units - (20 * units / minDist);
        step = (units / minDist) * 2;
    }
    if (minDist > 50)
    {
            //step = units / 5.0f;
        step = (units / minDist) * 20;
    }
    if (minDist > 100)
    {
            //step = units / 5.0f;
        step = (units / minDist) * 40;
    }

    step2 = step;
    float3 dadt0 = getBlackHoleAngleV2(bh, ray, shadowHit);
    if (shadowHit)
        return float3(0,0,0);
    float dt = step;
    float3 rot0 = dadt0 * dt;

    /*float3 dadt1 = getBlackHoleAngleV2(bh, CreateRay(ray.origin + ray.direction * step, ray.direction),shadowHit);
    if (shadowHit)
        return float3(0,0,0);
    float3 rot1 = dadt1 * dt;
    float3 rot = (rot0 + rot1) * 0.5f;*/
    return rot0;
}

bool calcRay6(Ray _ray)
{
    clearPoints();

    float step = 4;
    int steps = 50;

    uint n, stride;
    _BlackHoles.GetDimensions(n, stride);
        

    addPoint(_ray.origin);
    float3 prevVw = float3(0,0,0);

    /*float nearestDist = 9999999;
    int bhid = -1;
    for (int i = 0; i < (int)n; ++i)
    {
        BlackHole center = _BlackHoles[i];
        float d0 = getApproachCollisionDistance(_ray, center.position);
        if (d0 < nearestDist)
        {
            nearestDist = d0;
            bhid = i;
        }
    }
    if (nearestDist < 0)
        nearestDist = 0;

    _ray = CreateRay(_ray.origin + _ray.direction * nearestDist, _ray.direction);
    */

    float tmpStep = step;
    float mul = 1;
    for (int i = 0; i < steps; ++i)
    {
        float3 Vw = float3(0, 0, 0);
        for (int j = 0; j < n; ++j)
        {
            bool shadowHit;
            float3 prim = getBlackHoleAngleVPrim2(_BlackHoles[j], _ray, step, 
            shadowHit, 
            mul);
            Vw += prim;
            if (shadowHit)
            {
                float d = getApproachCollisionDistance(_ray, _BlackHoles[j].position);
                if (d > 0)
                {
                    addPoint(_ray.origin + _ray.direction * d);
                    addPoint(_BlackHoles[j].position);
                    return false;
                }
                
            }
        }
        if (i == 0)
            prevVw = Vw;
        float3 bend = (Vw + prevVw) / 2.0f;
        bend = Vw;

        float3 dir2 = rodrigez(_ray.direction, bend, length(bend));
        _ray = CreateRay(_ray.origin + dir2 * mul, dir2);
        addPoint(_ray.origin);

        prevVw = Vw;
    }
    addPoint(_ray.direction);

    return false;
}

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    _Pixel = id.xy;
    //Result[id.xy] = float4(1, 0.5, 0.5, 0);
    //return;
    qHead = 0;
    qTail = 0;
    qSize = 0;
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);
    float4 result = float4(0, 0, 0, 1);
    
    /*result = float4(1, 0, 0, 1);
    Result[id.xy] = result;
    return;*/

    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

    if (id.x == (int) (width / 2) && id.y == (int)(height / 2))
    {
        debug_locker = true;
    }

    // Get a ray for the UVs
    Ray camRay = CreateCameraRay(uv);

    //bool state = calcRay3(camRay);
    bool state = false;
    if(_bhCount > 0) {
        state = M4tester(camRay);
    }
    else
    {
        addPoint(camRay.origin);
        addPoint(camRay.direction);
    }
    //bool state = calcRay6(camRay);

    //if (debug_locker)
    //    DEBoutput[0] = normalize(points[pointCounter - 1]);


    RayHit rh;
    bool hit = Trace(rh);
    //bool hit = false;

    if (hit)
    {
        Result[id.xy] = rh.emission;

        //Result[id.xy] = float4(getSkyboxPixel(CreateRay(float3(0, 0, 0), normalize(points[pointCounter - 1]))), 1);
    }
    else
    {
        if (state)
        {
            Result[id.xy] = result;
        //Result[id.xy] = float4(getSkyboxPixel(CreateRay(float3(0, 0, 0), normalize(points[pointCounter - 1]))), 1);
        }
        else
        {
            Result[id.xy] = float4(getSkyboxPixel(CreateRay(float3(0, 0, 0), normalize(points[pointCounter - 1]))), 1);
            //Result[id.xy] *= 1.3f;

            float3 c = Result[id.xy].rgb;

            float jmax = 1;

            /*loat jmin = 0;
            float jmax = 1;

            float jNmin = 0;
            float jNmax = 0.1;

            c = (c - jmin) / (jmax - jmin) * (jNmax - jNmin) + jNmin;*/

            float alp = 1.2;

            //c = pow(c / jmax, alp);
            
            //Result[id.xy] = float4(c,1);
        }
    }

    
    return;






    //PushRay(camRay);
        Ray ray = camRay;
    //petlaGlowna
    float4 tmp = float4(0, 0, 0, 1);
    float ang = getBlackHoleAngle(_BlackHoles[0], ray);
    if (ang < 0)
    {
        tmp = float4(0, 0, 0, 1);
    }
    else
    {
        Ray r2 = bendRay(ray, ray.origin, _BlackHoles[0].position, ang);
        tmp = float4(getSkyboxPixel(r2), 1);

    }
    result += tmp;

    result = result / 1.0f;

    /*for (int i = 0; i < _rayLimit; i++)
    {
        //Ray ray;
        //bool err = PopRay(ray);
        
        //promien istnieje
        float ang = getBlackHoleAngle(_BlackHoles[0], ray);
        if (ang < 0)
        {
            result = float4(0,0,0,1);
        }
        else
        {
            Ray r2 = bendRay(ray, ray.origin, _BlackHoles[0].position, ang);
            result = float4(getSkyboxPixel(r2), 1);

        }
            
        
        break;
        if (!any(ray.energy))
        {
            break;
        }
    }*/
    Result[id.xy] = result;
}
